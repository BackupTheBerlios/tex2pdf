#!/usr/bin/perl -w

#      tex2pdf - script for translating latex docs to pdf
#
#      Copyright (C) 2000,2001 by Steffen Evers
#
#      This program is free software; you can redistribute it and/or modify
#      it under the terms of the GNU General Public License version 2 as 
#      published by the Free Software Foundation.
#
#      This program is distributed in the hope that it will be useful,
#      but WITHOUT ANY WARRANTY; without even the implied warranty of
#      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#      GNU General Public License for more details.
#
#      You should have received a copy of the GNU General Public License
#      along with this program; if not, write to the Free Software
#      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#      The GNU General Public License is also available online:
#      http://www.gnu.org/licenses/gpl.html
#
# Thanks a lot to all the people that have already contributed to this project!
#
# The changelog including the credits has become too long. So, I have removed it
# from the script, but it is still available online (see below). 
#
# Special thanks to the following people for their contribution
# (see the changelog for details):
# Matej Cepl, Herbert Voss, Nicolas Marsgui, Bruce Foster, Mark van Rossum,
# Matt Bandy, Garrick Chien Welsh, Stacy J. Prowell, Pavel Sedivy,
# Holger Daszler, Olaf Gabler, Ahmet Sekercioglui, Richard, Steffen Macke
#
# Project Homepage: http://tex2pdf.berlios.de
# Developer Homepage: http://developer.berlios.de/projects/tex2pdf
# Mailing lists: http://developer.berlios.de/mail/?group_id=57
# Changelog: http://tex2pdf.berlios.de/changelog.html
#
# Anyone is invited to help to improve tex2pdf. Therefore any kind of feedback
# is welcome. Maybe you even would like to hack the code and send us your
# changes. This would help a lot and is highly appreciated. Think about it :-)
# Subscribing to the developer mailing list might be a first step (see above).
#
# Send feedback to: tex2pdf-devel@lists.berlios.de
#

######## Imports

use File::Basename;
use Getopt::Long;
use Cwd;

####### Release version

$MYRELEASE="2.2.8pl";
$MYNAME="tex2pdf.pl";
@TMPFILES=();

##### You will need pdftex and epstopdf for the generation!
##### See pdftex homepage for details: http://tug.org/applications/pdftex/
##### Have fun!!!

##### Default parameters
## Change the parameters below if you want to change the default settings for
## all users.  If you only want to change your private parameters change them
## in the RC_FILENAME

### text token for no value
$NIL="NOVALUE";
$UNDEF="undefined";

### token for boolean 'false', 'no' 
$NO="no";
$FALSE=0;

### token for boolean 'true', 'yes' 
$YES="yes";
$TRUE=1;

### file to store private parameters
# If you only want to change your private parameters change them there
# default: $HOME/.tex2pdfrc
$RC_FILENAME="$ENV{'HOME'}/.tex2pdfrc";


########################## NEW PERL CONFIGURATON

%CONFIGURATION = ();
%PARAMETER_LIST = ();
%PARAMETER_TYPES = ();
 
## Array index for the various information in each parameter specifcation
## referenced by %PARAMETER_LIST
$TYPE=0;
$ALIAS=1;
$OPT_SPEC=2;
$DEF_VALUE=3;
$DESCRIPTION=4;
$EXPLANATION=5;
$QUESTION=6;

&add_param_type('paper',
   { 'a4paper' => 'a4 paper',
     'letterpaper' => 'letter paper',
     'legalpaper' => 'legal paper',
     'executivepaper' => 'executive paper',
     $NIL => 'do not set value - leave it to hyperref'
   } );
		  
&add_param_type('color', 
   { 'yellow' => 'LaTeX color yellow',
     'red' => 'LaTeX color red',
     'green' => 'LaTeX color green',
     'cyan' => 'LaTeX color cyan',
     'blue' => 'LaTeX color blue',
     'magenta' => 'LaTeX color magenta',
     'black' => 'LaTeX color black',
$NIL => 'do not set this value - leave it to hyperref'
   } );

&add_param_type('destination',
   { 'source' => 'directory of the LaTeX source document' ,
     'input' => 'root directory of referenced material',
     'custom' => 'custom directory as specified'
   } );

# $key, $type, $def_value, $opt_alias, $opt_spec, $description, $explanation, $question
&add_param('help', 'action', undef, '|h', '');
&add_param('version', 'action', undef, '|v', '');
&add_param('print_config', 'action', undef, '|o', '');
&add_param('configure', 'action', undef, '|r', '');
&add_param('logdir', 'directory',"/tmp/tex2pdf-$ENV{'USER'}/", '', '=s');
&add_param('clean_logs', 'bool', $YES, '|l', '!');
&add_param('check_commands', 'bool', $YES, '|c', '!');
&add_param('regexp_append', 'text', '^\\documentclass(\[[^]]*\])?\{.*\}', '', '=s');
&add_param('destination', 'destination', 'source', '', '=s');
&add_param('custom_path', 'directory', $ENV{'HOME'}, '|d', '=s');
&add_param('tmp_base_suffix', 'text', '-pdf', '', '=s');
&add_param('colorlinks', 'three', $YES, '', '!');
&add_param('paper', 'paper', 'a4paper', '|p', '=s');
&add_param('citecolor', 'color', 'red', '', '=s');
&add_param('urlcolor', 'color', 'blue', '', '=s');
&add_param('linkcolor', 'color', 'green', '', '=s');
&add_param('pagecolor', 'color', 'magenta', '', '=s');
&add_param('link_toc_page', 'bool', $YES, '', '!');
&add_param('default_title', 'text', $NIL, '', '=s');
&add_param('title', 'text', undef, '|t', '=s');
&add_param('default_author', 'text', $NIL, '', '=s');
&add_param('author', 'text', undef, '|a', '=s');
&add_param('force_index', 'bool', $NO, '|i', '!');
&add_param('bibtex', 'three', $NIL, '|b', '!');
&add_param('thumbpdf', 'bool', $NO, '|n', '!');
&add_param('maxrun', 'integer', 6, '', '=i');
&add_param('minrun', 'integer', 2, '', '=i');
&add_param('pdftex_opts', 'text', $NIL, '', '=s');
&add_param('hyperref_opts', 'text', $NIL, '', '=s');

# the following parameter types should be set now:
#  'color' => \%VALUES,
#  'destination' => \%VALUES,
#  'paper' => \%VALUES,
#  'three' => undef,
# 'bool' => undef,
#  'integer' => undef,
#  'text' => undef,
#  'directory' => undef

##### Functions ###########################################

### Index of the first occurence of a string in an array
# parameter 1: list
# parameter 2: text
# return value: index or -1 if not element of the array 

sub array_index {
   my (@list, $text) = @_;

   foreach (0..$#list)) {
      if ( @list[$_] eq $text ) { return $_; }
   }
   
   return -1;
}

### Removing all temporary files

sub clean_up {
   print "$MYNAME: Removing temporary files ...\n";
   if ( @TMPFILES > 0 ) { unlink @TMPFILES; }
   # if ( $TMPBASE ne "" ) { unlink glob "$TMPBASE.*"; }
}

###  exit with an error message

sub abort {
   print "$MYNAME: @_\n";
   if ( &param_value('CLEAN_ON_ABORT') eq $YES ) { &clean_up; }
   print "Aborting ...\n";
   exit 1;
}

### Check for required command with 'which'; abort if not found
# parameter $1: command to check
# parameter $2: remark if specified command is not found

sub checkCommand {
   my $command = $_[0];
   my $message = $_[1];

   $_ = `which $command 2>&1`; 
   chomp;
   s|^(.*/)?([^/]+)$|$2|;

   if ( $_ ne $command ) {
      print "\n";
      system "which", $command;
      print "\n$MYNAME: Required command '$command' seems not to be in your path.\n";
      if ( defined($message) ) {
         print "$message\n";
      }
      print "Aborting ...\n";
      exit 1;
   }
}

###################### Generic configuration functions

### interactively answer a question with yes or no
# parameter 1: question
# parameter 2: default value (not set means $NIL)
# parameter 3: yes: allow undefined as third value
#              no : only yes/no allowed (default)
# return value: the given answer

sub question_ynu {
   my $user_input;
   my $question = $_[0];
   my $default = defined($_[1]) ? $_[1] : $NIL;
   my $undef_allowed = defined($_[2]) and $_[2] eq $YES;
   my $response = undef;

   if( $default =~ /^y(es)?/i ) {
      $question .= ' [y]: ';
      $default = $YES;
   } elsif ( $default eq $NIL and $undef_allowed ) {
      $question .= ' [u]: ';
      $default = $NIL;
   } else {
      $question .= ' [n]: ';
      $default = $NO;
   }
   while (! defined($response)) {
      print $question;
      $user_input = <STDIN>;
      chomp($user_input);
      
      if( $user_input =~ /^y(es)?/i ) {
         $response=$YES;
      } elsif ( $user_input =~ /^no?/i ) {
         $response=$NO;
      } elsif ( $user_input =~ /^u(ndef(ined)?)?/i and $undef_allowed ) {
         $response=$NIL;
      } elsif ( $user_input eq "" ) {
         $response=$default;
      } else {
         print "Please respond with y(es)";
         print ", u(ndefined)" if($undef_allowed);
         print " or n(o).\n";
      }
   }
   return $response;
}

### interactively input a positive integer number
# parameter 1: question
# parameter 2: default value
# parameter 3: min value
# parameter 4: max value
# return value: the input number

sub input_number {
   my $question = $_[0];
   my $default = $_[1];
   my $min_limit = $_[2];
   my $max_limit = $_[3];
   my $response= undef;

   while (! defined($response)) {
      print "$question [$default]: ";
      my $user_input = <STDIN>;
      chomp($user_input);
      
      if ($user_input eq "") {
         $response=$default;
      } else {
         $_ = $user_input;
         if (s/^([[:digit:]]+)$/$1/ and $_ >= $min_limit and $_ <= $max_limit ) {
            $response = $_;
	 } else {
            print "Invalid input. Please enter a positve integer from $min_limit to $max_limit.\n";
         }
      }
   }
   return $response;
}

### interactively choose between several given values
# parameter 1: question
# parameter 2: default value
# parameter 3: reference to hash list of possible values
# return value: the chosen value

sub choose_value {
   my ($question, $default, $values_hash_ref)=@_;
   my $list_index=1;
   my $default_no=1;
   my $chosen_no;
   my @possible_values = keys %$values_hash_ref;

   print "$question\n";
   foreach (@possible_values)
   {
      print '$list_index) ' . ${$values_hash_ref}{$_} . "\n";
      if ( $default eq $_ ) { $default_no=$list_index; }
      $list_index = $list_index + 1;
   }

   $chosen_no=&input_number("Please enter the corresponding number", $default_no, 1, $#possible_values);
   return $possible_values[$chosen_no - 1];
}

### interactively answer a question
# parameter 1: question
# parameter 2: current value
# return value: the new value

sub input_text {
   my $question=$_[0];
   my $default=$_[1];
   my $response= undef;

   print "Suggested value: $default\n";
   if ( &question_ynu("Do you want to keep this value?", $YES) eq $YES ) {
      $response= $default;
   } else {
      print "$question ";
      my $user_input = <STDIN>;
      chomp($user_input);
      
      $response = $user_input;
   }
   return $response;
}

##### Make sure that specified file exists and is readable; abort if missing
# parameter 1: file to check
# parameter 2: remark if check fails on specified file

sub check_file {
   my $file = $_[0];
   my $message = defined($_[1]) ? $_[1] : "Required file cannot be accessed!";

   if ( ! -f $file ) {
      print "\n$MYNAME: Sorry. I cannot find '$file'.\n";
      &abort($message);
   } elsif ( ! -r $file ) {
      print "\n$MYNAME: Sorry. File '$file' exists, but is not readable.\n";
      &abort($message);
   }
}

##### Make sure that specified directory exists and is writable
# parameter 1: directory to check
# parameter 2: remark if check fails on specified directory
# parameter 3: if yes, creation is allowed
# return value: $TRUE - ok; $FALSE - error

sub check_dir {
   my $directory = $_[0];
   my $message = defined($_[1]) ? $_[1] : "Not a valid path!";
   my $allow_creation = defined($_[2]) ? $_[2] : $NO;

   if ( index($directory, "/") != 0 ) {
      print "\n$MYNAME: Sorry. '$directory' is not an absolute path.\n";
      print "$message\n";
      return $FALSE;
   } elsif ( ! -d $directory ) {
      # dir does not exist
      print "\n";
      if ( $allow_creation eq $YES ) {
         # creation allowed
         print "$MYNAME: I cannot find '$directory'. Try to create it.\n";
	 if ( mkdir($directory, 0755) ) {
	    print "Creation of '$directory' was successful.\n";
	    return $TRUE;
	 } else {
	    print "$MYNAME: Creation of '$directory' failed.\n";
	    print "$message\n";
	    return $FALSE;
	 }
      } else {
         # creation not allowed
         print "$MYNAME: Sorry. Directory '$directory' does not exist.\n";
         print "$message\n";
         return $FALSE;
      }
   } elsif ( ! -w $directory ) {
      # dir not writable
      print "\n$MYNAME: Sorry. Directory '$directory' exists, but is not writable.\n";
      print "$message\n";
      return $FALSE;
   }
   return $TRUE;
}

### interactively input a directory for data storage (absolute path)
# parameter 1: question
# parameter 2: default dir
# parameter 3: if 'yes' allow creation of directory
# return value: the specified directory

sub input_dir {
   my $question = $_[0];
   my $default_dir = $_[1];
   my $allow_creation = defined($_[2]) ? $_[2] : $NO;
   my $user_input;
   my $response = undef;

   if ( defined($default_dir) and index($default_dir, "/") == 0 
        and ( (! -d $default_dir and $allow_creation eq $YES) 
        or (-d $default_dir and -w $default_dir) ) ) {
      $question .= " [$default_dir]: ";
   } else {
      $default_dir = undef;
      $question .= ": ";
   }

   while (! defined($response)) {
      print "$question";
      $user_input = <STDIN>;
      chomp($user_input);
      
      if( $user_input eq "" and defined($default_dir) ) {
         # user has only pressed <ENTER> and thereby confirmed default value
	 if( ! &check_dir($default_dir,"Default value was not valid. Please, give different directory.", $allow_creation ) ) {
	    # default dir does not exist and cannot be created
	    $default_dir = undef;
	    $question = "$_[0]: ";
	 } else {
	    # valid default dir has already existed or has been created
            $response = $default_dir;
	 }
      } else {
         # user has given a directory
         if( &check_dir($user_input,"This is not a valid directory!", $allow_creation) ) {
	    $response = $user_input;
         }
      }
   }
   return $response;
}

#### add a new parameter type with corresponding hash table to the adminstrated
#### parameters types
# parameter 1: type key
# parameter 2: additonal data for the type
#              e.g. for enum type: reference to hash table
# return value: none

sub add_param_type {
 
   my ($type, $scalar_argument) = @_;
 
   $PARAMETER_TYPES{$type} = $scalar_argument;
}

#### add a new parameter to the adminstrated parameters
####
# parameter 1: key
# parameter 2: type
# parameter 3: default value
# parameter 4: alias for command line options
# parameter 5: specification for command line options
# parameter 6: short description for help
# parameter 7: explanation
# parameter 8: question
# return value: none

sub add_param {
 
   my ($key, $type, $def_value, $opt_alias, $opt_spec, $description, $explanation, $question) = @_;
 
   $CONFIGURATION{$key} = $value;

   $PARAMETER_LIST{$key} = [ $type, $alias, $opt_spec, $def_value, $description, $explanation, $question ];
   
   if (! exists $PARAMETER_TYPES{$type}) {
      $PARAMETER_TYPES{$type} = undef;
   }
}

### get the value of an existing parameter
# parameter 1: a parameter key
# return value: parameter value

sub param_value {
   my $key = $_[0];
   my $current_value;

   exists(%CONFIGURATION{$key})
      or &abort "unknown parameter: $key";
   $current_value = %CONFIGURATION{$key};

   return $current_value;
}

### get the value of an existing parameter
# parameter 1: a parameter key
# return value: parameter value

sub param_type {
   my $key = $_[0];
   my $def_ref;
   my $type;

   exists(%PARAMETER_LIST{$key})
      or &abort "unknown parameter: $key";
   $def_ref = %PARAMETER_LIST{$key};
   $type = @{$def_ref}[$TYPE];

   return $type;
}

### set the value of an existing parameter
# parameter 1: a parameter key
# parameter 2: the new value
# return value: none

sub set_param_value {
   my $key = $_[0];
   my $new_value = $_[1];

   exists(%CONFIGURATION{$key})
      or &abort "unknown parameter: $key";
   %CONFIGURATION{$key}=$new_value;
}

### get option specifier for getopts
# parameter 1: option key
# return value: string - option specifier

sub option_specifier {
   my $key = $_[0];
   my $spec;
   my $def_ref;
 
   exists(%PARAMETER_LIST{$key})
      or &abort "unknown parameter: $key";
   $def_ref = %PARAMETER_LIST{$key};
   $spec = $key . @{$def_ref}[$OPT_ALIAS] . @{$def_ref}[$OPT_SPEC];
 
   return $spec;
}

### handle an option
# parameter 1: a parameter/option key
# parameter 2: the option value
# return value: none

sub handle_option {
   my $key = $_[0];
   my $value = $_[1];
   my $type;
   
   $type = &param_type($key);

   if ($type eq 'action') {
      &handle_action_opt($key, $value);
   } else {
      &set_param_value($key, $value);
   }
# bash code FIXME
#     case "$OPTION" in;
#       i) &setYNValue MAKEINDEX $OPTARG i ;;;
#       t) $TITLE=$OPTARG ;;;
#       a) $AUTHOR=$OPTARG ;;;
#       b) &setValue BIBTEX $OPTARG b $POSSIBLE_BIBTEX ;;;
#       p) &setValue PAPERSIZE $OPTARG p $POSSIBLE_PAPER ;;;
#       c) &setYNValue COMMANDCHECK $OPTARG r ;;;
#       n) &setYNValue THUMBNAILS $OPTARG n ;;;
#       l) &setYNValue CLEANLOGS $OPTARG l ;;;
#       d) if &check_dir($OPTARG);
#   	     $PDFCUSTOMDIR=$OPTARG;
#   	     $PDFOUT=@$POSSIBLE_PDFOUT[2];
#   	  } else {
#   	     &abort("Please, choose a VALID path.");
#   	  fi ;;;
#     esac;
}

### handle all action options 
# parameter 1: a option key
# parameter 2: the option value
# return value: none

sub handle_action_opt {
   my $key = $_[0];
   my $value = $_[1];

   if ($key eq 'help') {
      &help;
      
   } elsif ($key eq 'version') {
      &print_version;
      
   } elsif ($key eq 'configure') {
      if ( -f $RC_FILENAME ) {
         &read_configuration $RC_FILENAME;
      }
      &configure;
      &write_configuration $RC_FILENAME;
      &print_configuration;
      
   } elsif ($key eq 'print_config') {
      if ( -f $RC_FILENAME ) {
         &read_configuration $RC_FILENAME;
      }
      &print_configuration;

   } else {
      &usage; 
      exit 1;
   }
   exit 0;
}

### set a variable by a command line option to 'yes' or' no'; abort on error
# parameter 1: variable
# parameter 2: given value
# parameter 3: option letter

sub setYNValue {
   my $variable = $_[0];
   my $argument = $_[1];
   my $option_letter = $_[2];

   if( $argument =~ /^[yY]([Ee][Ss])?/ ) {
      $$variable = $YES;
   } elsif ( $argument =~ /^[Nn][Oo]?/ ) {
      $$variable = $NO;
   } else {
      print "\n$variable requires '$YES' or '$NO'." ;
      &abort("Illegal argument for option -$option_letter: $argument");
   }
}

### set a variable by a command line option to a possible values; abort on error
# parameter 1: variable
# parameter 2: given value
# parameter 3: option letter
# parameter 4: list of possible values

sub setValue {
   my $variable = $_[0];
   my $argument = $_[1];
   my $option_letter = $_[2];

   shift @_;
   shift @_;
   shift @_;

   my @possible_values = @_;

   if ( index("@possible_values", $argument) < 0 ) {
      print "\n$variable allows: @possible_values.\n";
      &abort("Illegal argument for option -$option_letter: $argument");
      exit 1;
   }
   $$variable = $argument;
}

### configure an existing parameter interactively
# parameter 1: question
# parameter 2: a parameter key
# return value: none

sub config_param {
   my $question = $_[0];
   my $key = $_[1];
   my $type; 
   my $new_value;
   my $current_value;

   exists(%PARAMETER_TYPES{$key})
      or &abort "unknown parameter: $key";
   $type = %PARAMETER_TYPES{$key}; 

   $current_value = &param_value($key);

   exists(%TYPE_VALUES{$type})
      or &abort "unknown parameter type: $key";

   if ($type eq 'bool') {
      $new_value=&question_ynu($question, $current_value, $NO);
   } elsif ($type eq 'three') {
      $new_value=&question_ynu($question, $current_value, $YES);
   } elsif ($type eq 'directory') {
      $new_value=&input_dir($question, $current_value, $YES);  
   } elsif ($type eq 'text') {
      $new_value=&input_text($question, $current_value);  
   } elsif ($type eq 'integer') {
      $new_value=&input_number($question, $current_value,
      $NUM_PARAM_MIN, $NUM_PARAM_MAX);  
   } else {
      my @possible_values; 
      my $values_hash_ref; 

      $values_hash_ref=%TYPE_VALUES{$type}; 
      if (! defined($values_hash_ref)) {
         &abort "do not know how to configure this parameter: $key (type: $type)";
      }

      $new_value=&choose_value($question,$current_value,$values_hash_ref);
   } 

   &set_param_value($key, $new_value);
}

### save configuration in rc file
# parameter 1: file name
# return value: none

sub write_configuration {
   my $file_name = $_[0];
   my $date;
   my $key;
   my $value;

   open(RCFILE, ">$file_name") or
      &abort("Could not open configuration file for writing ($file_name)");
   select RCFILE;

   $date = `date`;
   chomp($date);
   
   print "# Configuration file for $MYNAME V$MYRELEASE\n";
   print "# Generated $date by $ENV{'USER'} on $ENV{'HOSTNAME'}\n";
   
   while (($key, $value) = each %CONFIGURATION ) {
      print "$key".'='."$value\n" if(&param_type($key) ne 'action');
   }
   
   print "# EOF\n";
   select STDOUT;
   close RCFILE;
}

### print the configuration parameters

sub print_configuration {
   my $key;
   my $value;

   print "Configuration for $MYNAME V$MYRELEASE\n";
   
   while (($key, $value) = each %CONFIGURATION ) {
      print "$key".'='."$value\n" if(&param_type($key) ne 'action');
   }
   
   print "\n";
}

### load parameters from rc file
# parameter 1: file name
# return value: none

sub read_configuration {
   my $file_name = $_[0];

   &check_file($file_name, "Could not access configuration file");
   open(RCFILE, "<$file_name") or
      &abort("Could not open configuration file for reading ($file_name)");

   while (<RCFILE>) {
         chomp;
         if( /^([^#=]+)=([[:print:]]*)$/ and exists $CONFIGURATION{$1} ) {
            $CONFIGURATION{$1} = $2; 
         }
      }
   }
   close RCFILE;
}

### print script version

sub print_version {
   print "\n$MYNAME Version $MYRELEASE\n\n";
}

###################### Specific functions (for use with this script only)

### print usage of command

sub usage {
   print "\nUsage: $MYNAME [OPTIONS] DOCUMENT.lyx\n";
   print "       $MYNAME [OPTIONS] DOCUMENT.tex\n";
   print "       $MYNAME [-h|-v|-o|-r]\n\n";
}

### print command help

sub help {
   print "\n$MYNAME Version $MYRELEASE\n";
   &usage;
   print " -h : print this message\n";
   print " -v : print version information\n";
   print " -o : print configuration parameters\n";
   print " -r : run configure parameters\n";
   print "\n";
   print " -i BOOL   : makeindex\n";
   print " -l BOOL   : clean log files\n";
   print " -c BOOL   : check for required commands\n";
   print " -n BOOL   : generate thumbnails for PDF document\n";
   print " -t TITLE  : specify title for PDF document info\n";
   print " -a AUTHOR : specify author for PDF document info\n";
   print " -p SELECT : select papersize: @$POSSIBLE_PAPER\n";
   print " -b SELECT : select bibtex handling: @$POSSIBLE_BIBTEX\n";
   print " -d PATH   : custom directory where the final PDF is stored\n\n";
}

### configure all tex2pdf parameters interactively
# parameters: none
# return value: none

sub configure {
   print "\nConfiguration for tex2pdf.\n";
   print "The following answers are considered as defaults in later executions\n";
   print "of $MYNAME. You can change these values by using option -r.\n";
   print "The command-line options override these settings.\n";
   print "Many parameters can be set to '$NIL'. This means that NO value at\n";
   print "all (not even an empty value) is passed over to the called\n";
   print "application (e.g. latex package hyperref).\n";

   print "\n----------------\n";
   print "$MYNAME can set the papersize of the resulting PDF document.\n";
   &config_param("What papersize should be used?", 'paper');

   print "\n----------------\n";
   print "The table of contents of the resulting PDF document is normally linked\n";
   print "to the corresponding section. However, you can also link it to the\n";
   print "corresponding page instead.\n";
   &config_param("Should TOC be linked to pages?",'linktocpage');

   print "\n----------------\n";
   print "$MYNAME can use different colors for links inside the PDF document.\n";
   &config_param("Should colors be used for links?",'colorlinks');

   if ( &param_value('colorlinks') eq $YES ) {
        print "\n----------------\n";
        print "It is possible to specify the color for page links.\n";
        &config_param("What color should be used for page links?",'pagecolor');

        print "\n----------------\n";
        print "It is possible to specify the color for normal internal links.\n";
        &config_param("What color should be used for normal links?",'linkcolor');

        print "\n----------------\n";
        print "It is possible to specify the URL color.\n";
        &config_param("What color should be used for URLs?",'urlcolor');

        print "\n----------------\n";
        print "It is possible to specify the citation color.\n";
        &config_param("What color should be used for citation?",'citecolor');
   }

   print "\n----------------\n";
   print "A PDF document contains meta data about itself: the document info.\n";
   print "Two of the info fields (title, author) can be set here as default\n";
   print "value which will be used in the case that $MYNAME cannot determine\n";
   print "proper settings from the LaTeX document.\n\n";

   print "The default title for the document info of all generated documents.\n";
   print "$NIL will be recognized and means pass no value at all than.\n\n";
   &config_param("Default document title?",'default_title');

   print "\n----------------\n";
   print "The default author for the document info of all generated documents.\n";
   print "$NIL will be recognized and means pass no value at all than.\n\n";
   &config_param("Default document author?",'default_author');

   print "\n----------------\n";
   print "If you like you can make me pass additional parameters to hyperref.\n";
   print "See the hyperref manual for possible values and details.\n";
   print "These parameters should normally have the format:\n";
   print "PARAMETERNAME={VALUE},PARAMETERNAME={VALUE},...\n";
   print "Leave blank for no additional values.\n\n";
   &config_param("Additional parameters ?",'hyperref-opts');

   print "\n----------------\n";
   print "You can now specify in which directory the resulting document should\n";
   print "be written by default:\n";
   print "- '@$POSSIBLE_PDFOUT[0]' means the same directory as the LaTeX file.\n";
   print "- '@$POSSIBLE_PDFOUT[1]' means the same directory as the input files of your\n";
   print "  LaTeX file (e.g. images, included documents, etc.).\n";
   print "  This path should be specified in the source LaTeX document otherwise\n";
   print "  it is identical with the '@$POSSIBLE_PDFOUT[0]' option.\n";
   print "- '@$POSSIBLE_PDFOUT[2]' means you want to specify your own directory where the\n";
   print "  generated document should be written.\n";
   &config_param("Which output directory?",'destination');

   if ( &param_value('PDFOUT') eq @$POSSIBLE_PDFOUT[2] ) {
      print "\n----------------\n";
      print "You have choosen to specifiy a custom output directory.\n";
      &config_param("What custom directory should be used?",'custom-path');
   }

   print "\n----------------\n";
   print "The bibtex usage can be specified.\n";
   print "Possible values are: '$YES' (always run bibtex), '$NO' (never run\n";
   print "bibtex) and '$UNDEF' (scan tex file for a bibtex entry and run it\n";
   print "if required).\n";
   &config_param("How should bibtex be used?",'bibtex');

   print "\n----------------\n";
   print "The maximal number of runs for pdflatex can be specified.\n";
   $NUM_PARAM_MIN=1;
   $NUM_PARAM_MAX=9;
   &config_param("What should be the maximum number of runs for pdflatex?",'maxrun');

   print "\n----------------\n";
   print "The minimal number of runs for pdflatex can be specified.\n";
   print "Possible values are: 1 ... &param_value('MAXRUNNO').\n";
   $NUM_PARAM_MIN=1;
   $NUM_PARAM_MAX=$MAXRUNNO;
   &config_param("What should be the minimum number of runs for pdflatex?",'minrun');

   print "\n----------------\n";
   print "The log directory is used to store information about the generation\n";
   print "process for later review, e.g. for debugging.\n";
   &config_param("What log directory should be used?",'logdir');

   print "\n----------------\n";
   print "$MYNAME can clean the log files before execution.\n";
   print "You might experience problems if you run $MYNAME on several documents\n";
   print "the same time. If you want to be on the safe side, answer '$NO'.\n";
   &config_param("Should the log files be cleaned before execution?",'cleanlogs');

   print "\n----------------\n";
   print "$MYNAME can check for the required executables.\n";
   &config_param("Should $MYNAME check for the required executables?",'commandcheck');

   print "\n----------------\n";
   print "$MYNAME can use thumbpdf to include thumbnails of the document pages.\n";
   print "This requires Ghostscript 5.50 or higher.\n";
   &config_param("Should PNG thumbnails be created?",'thumbpdf');

   print "\n----------------\n";
   print "$MYNAME can force the call of makeindex if pdftex fails to do this.\n";
   &config_param("Should the call of makeindex be forced?",'forceindex');

   print "\n----------------\n";
   print "Additional options for pdflatex can be specified.\n";
   print "Normally, you can leave this blank.\n\n";
   &config_param("What additional options for pdflatex should be used?", 'pdftex-opts');
   print "\n";
}

### check if the most important executables are installed on the system
# parameters: none

sub check_commands {
   ### check for which command
   &checkCommand("which","You can switch off all command checks by setting &param_value('COMMANDCHECK')=$NO in the parameter section of $MYNAME.");

   ### sed executable
   # GNU sed version 3.02 or higher is recommended
   # Download: ftp://ftp.gnu.org/pub/gnu/sed
   if ( &param_value('SEDEXE') eq "sed" ) {
      &checkCommand("sed","You should get GNU sed 3.02 or later: ftp://ftp.gnu.org/pub/gnu/sed");
   }

   ### pdftex executables
   # Homepage: http://tug.org/applications/pdftex
   &checkCommand("pdflatex","See pdftex homepage for details: http://tug.org/applications/pdftex");
   &checkCommand("epstopdf","See pdftex homepage for details: http://tug.org/applications/pdftex");

   if ( &param_value('THUMBNAILS') eq $YES ) {
      &checkCommand("thumbpdf","You can switch off thumbpdf support by setting &param_value('THUMBNAILS')=$NO in the parameter section of $MYNAME.");
   }

   ### bibtex executable
   if ( &param_value('BIBTEX') ne $NO ) {
      &checkCommand("bibtex","You can switch off BibTeX support by setting &param_value('BIBTEX')=$NO in the parameter section of $MYNAME.");
   }
}

#### generate the tmp file name from the original tex filename
#### and make sure that they are not the same
# parameter 1: orignal filename (with or without a path, but with .tex)

sub get_tmp_filename {
   my $original_name = $_[0];
   my $tmp_name = $original_name;

   $tmp_name =~ s/(\.tex)$/&param_value('TMPBASESUFFIX')$1/;
      
   if ($original_name eq $tmp_name) {
      &abort("Original and temporary filenames are identical ($original_name).");
   }
   return $tmp_name;
}

### generate LaTeX file from LyX document with LyX itself
# parameter ($1): Lyx document
# parameter ($2): Latex document

sub generate_tex_file {
   my $lyx_doc = $_[0];
   my $tex_doc = $_[1];
   my $lyx_dir = "$ENV{'HOME'}/.lyx/";

   ### Check if LyX file can be accessed
   &check_file($lyx_doc,"Cannot read the specified LyX document!");

   ### Check if LaTeX file exists and is newer than the LyX file
   if ( -f $tex_doc and $tex_doc -nt $lyx_doc ) {
      print "\n";
      print "$MYNAME: LaTeX file is newer than LyX document '$lyx_doc'.\n";
      print "Using existing TeX file: $tex_doc\n";
      print "Remove it to force its new generation.\n";
   } else {
      ### export LaTeX file with LyX (needs a display!)
      &checkCommand("lyx","Cannot generate LaTeX document without LyX!");
      print "\n";
      print "$MYNAME: Exporting LaTeX file\n";
      
      foreach my $file ($lyx_dir."lyxpipe.out",$lyx_dir."lyxpipe.in",$tex_doc) {
         if ( -f $file ) { rename($file, $file.'~'); }
      }

      system "lyx --export latex $lyx_doc";

      ### check if LaTeX file now really exists
      &check_file($tex_doc,"The LaTeX document was not generated by LyX!");
   }
}

#### search TeX document for a certain text tag (e.g. author, title)
# parameter 1: file to parse
# parameter 2: full TeX tag name
# return value: contents of the tag as a string (undef if not found)

sub extract_tag_text {
   my $source=$_[0];
   my $tag_name=$_[1];
   my $result = undef;
   my $error_message="Could not read TeX document to extract $tag_name";

   &check_file($source, $error_message.'.');
   open(SOURCE_FILE, "<$source") or
      &abort($error_message."($source).");

   while(<SOURCE_FILE>) {
      s/([^\])%.*$/$1/;
      if( /\\$tag_name(\[[^{]*\])?{([^{}]*)}/ ) {
         $result=$2; 
	 last;
      }
   }
   
   close SOURCE_FILE;
   
   if ( ! defined($result)) {
      print "\n$MYNAME: WARNING: Could not identify document's $tag_name correctly.\n";
      print "Maybe you have used a LaTeX tag inside the $tag_name which confuses me.\n";
      print "Adjust the $tag_name of the LaTeX file in order to avoid the problem.\n";
      print "Additionally, it might be possible to set $tag_name manually when";
      print "calling $MYNAME.\n";
   }

   return $result;
}

### generate hyperref parameters from given settings
# parameter 1: main tex doc
# return_value: result

sub generate_hyperref_params {
   my $texdoc = $_[0];
   my $para;
   my @params = ('pdftex');

   ##### Set title and author from main LaTeX document or parameters
   foreach my $info (('title', 'author')) {
      my $value;

      $value=&param_value("$info");
      if (! defined($value) ) {
         $value=&extract_tag_text($texdoc, "$info");
         if (! defined($value) ) {
            $value= &param_value("default-$info");
         }
      }
      if (! defined($value) or $value eq $NIL ) {
            print "$info field set to $NIL - no value will be passed.\n";
         } else {
            print "Document's $info: $value\n";
            push(@params, "pdf$info={$value}");
         }
      }
   }
   
   print "\n";
   
   $para=&param_value('paper');
   if ( $para ne $NIL ) { push(@params, $para); }
   
   if ( &param_value('linktocpage') eq $YES ) { push(@params, 'linktocpage'); }

   $para=&param_value('colorlinks');
   if ( $para ne $NIL ) {
      $para= $para eq $YES ? 'true' : 'false';
      push(@params, "colorlinks=$para");
   }

   if ( $para ne 'false' ) {
      foreach (('linkcolor', 'pagecolor', 'urlcolor', 'citecolor')) {
         $para=&param_value($_);
      if ( $para ne $NIL ) { push(@params, "$_={$para}"); }
   }

   $para=&param_value('hyperref-opts');
   if(defined($para) and $para ne "" and $para ne $NIL) {
      push(@params, $para);
   }
   
   return @params;
}

##### read and analyse configuration and options and adjust basic variables
##### accordingly
#### The following sources are considered (last value overrides previous)
# general configuration (global variables in the script)
# private configuration (in user's RC file)
# command line options

sub adjust_configuration {
   my $configured=$FALSE;
   my %opt_specs =();

   ### Check number of arguments
   if ( @ARGV == 0 ) {
      print "\n$MYNAME: I need at least one argument!\n";
      &usage;
      exit 1;
   }
   
   ##### command line options and private configuration files handling
   
   ### set parameters from rc file
   if ( -f $RC_FILENAME ) {
      &read_configuration $RC_FILENAME;
      $configured=$TRUE;
   }
   
   ### scan parameters 
   foreach (keys %PARAMETER_LIST) {
      %opt_specs{&option_specifier($_)} = \&handle_option;
   }
   GetOptions(%opt_specs);

   if( ! $configured ) {
      &abort "Script is not configured. Please run $MYNAME -r.";
   }
   
   #### do some test in order to secure as good as possible that we will
   #### succeed before to much work was done and maybe some data as damaged

   ### Check number of arguments
   if ( @ARGV != 1 ) {
      print "\n$MYNAME: Wrong number of arguments. I need exactly one file.\n";
      &usage;
      exit 1;
   }
   
   ### make sure that TMPBASESUFFIX is not empty
   if ( &param_value('TMPBASESUFFIX') eq "" ) {
      print "\n$MYNAME: CAUTION: Parameter TMPBASESUFFIX is not set.\n";
      &abort "Using these settings would destroy the original files!";
   }
   
   ##### check for required commands
   if (&param_value('COMMANDCHECK') ne $NO ) {
      &check_commands;
   }
}

#### prepare the script to write some information to specified log files

sub prepare_logfiles {
   my $log_dir= &param_value('logdir');

   ##### Preparing the LOGDIR
   if ! mkdir -p $log_dir
      print "\n$MYNAME: Could not create log directory ($log_dir).\n";
      print "Aborting ...\n";
      exit 1;
   }
   
   if( `ls $log_dir` ne "" and &param_value('cleanlogs') eq $YES ) { #FIXME
      print "\nRemoving old log files ($log_dir).\n";
      unlink (glob "${log_dir}pdflatex-*.log", glob "${log_dir}bibtex-*.log", glob "${log_dir}thumbpdf-*.log");
   } else {
      print "\nAll log files will be stored in ($log_dir).\n";
   }
   
   # setting the log files for the output of pdflatex, bibtex and thumbpdf
   $PDFLOGBASE="${log_dir}pdflatex-$$-"; #FIXME
   $BIBTEXLOG="${log_dir}bibtex-$$.log";
   $THUMBPDFLOG="${log_dir}thumbpdf-$$.log";
}

##### analyse document argument
#### process the one and only argument (besides the options) which specifies
#### which LaTeX document the user wants to translate to PDF
#### a lyx file will be translated to LaTeX first

sub process_doc_argument {
   
   ##### Getting document name and path
   $DOCUMENT="$_[0]";
   $DOCNAME=`basename $DOCUMENT`;
   $DOCPATH=`echo "$DOCUMENT" | &param_value('SEDEXE') -e "s/^\(.*\)$DOCNAME/\1/"`;
   
   ###### change working directory to document directory
   if ( $DOCPATH ne "" ) {
      chdir $DOCPATH;
   }
   
   ###### make DOCPATH an absolute path
   $DOCPATH = cwd.'/';
   
   ###### Cut off suffix and do lyx or tex specific stuff
   $DOCBASE=`basename $DOCNAME .lyx`;
   if ( $DOCBASE ne $DOCNAME ) {
      ### DOCNAME has an extention .lyx => Lyx document
      # generate Latex document if required
      &generate_tex_file($DOCBASE.'.lyx', $DOCBASE.'.tex');
   } else {
      ### given file is a LaTeX file
      # cut off .tex extension if there is one
      $DOCBASE=`basename $DOCNAME .tex`;
   
      ###### check access to given LaTeX document
      &check_file("$DOCBASE.tex", "Cannot read the specified LaTeX document!");
   }
   
   $PASSEDTEXDOC=${DOCPATH}${DOCBASE}.tex;
   $TMPBASE=${DOCBASE}&param_value('TMPBASESUFFIX')
}

#### set theworking dir to the input path if the document has one and
#### and determine the path for the result
# parameter 1: main tex doc
# return value: absolute path were the resulting pdf doc should be stored

sub get_pdf_path {
   my $texdoc = $_[0];
   my $inputpath;
   my $doc_path= cwd . '/';
   my $destination;
   my $pdf_path;
 
   ###### change working directory to input_path if set
   # When the files' path (images, included documents, etc.) in your document is
   # relative to another directory than the PASSED document's directory.
   # This is useful when the calling application (e.g. LyX) generates a temporary
   # TeX file and calls the tex2pdf with it instead of the original file.
   $input_path=`&param_value('SEDEXE') -n "s|^[\]def[\]input@path{\+\([^{}]*\)}\+|\1|1p" $texdoc`;
       #FIXME
   
   ## check if input_path is ok
   if ( $input_path ne "" ) {
      print "$MYNAME: Found an input path in the latex document: $input_path\n";
      if ( -d $input_path and -r $input_path ) {
         print "Change working directory to input path.\n";
         chdir $input_path;
      } else {
          &abort 'The retrieved input@path seems not to be valid.';
      }
   } else {
      print "$MYNAME: No input path in the latex document found.\n";
      print "Resources are expected to be relative to document's location: $doc_path\n";
   }

   ##### set the directory where the final pdf will be stored
   $destination=&param_value('destination');
   $pdf_path=undef;

   if ($destination eq 'custom' ) {
      $pdf_path=&param_value('custom-path');
   } elsif ($destination eq 'input') {
      $pdf_path=$input_path;
   }

   if(! defined($pdf_path) or $pdf_path eq "" ) {
      $pdf_path=$doc_path;
   }

   return $pdf_path;
}

#### search for filenames in given TeX Tag in entire document
### skip all comments and duplicates while parsing
# parameter 1: file to parse
# parameter 2: full TeX tag name
# parameter 3: regular expression for the filname suffix (including '.')
# return value: list of found files

sub extract_files {
   my $source=$_[0];
   my $tag_name=$_[1];
   my $suffix=$_[2];
   my $matched_file;
   my @found_files=();

   &check_file($source, "Could not access TeX document to extract filenames.");
   open(SOURCE_FILE, "<$source") or
      &abort("Could not open TeX document to extract filenames ($source)");

   while(<SOURCE_FILE>) {
      chomp;
      s/([^\])%.*$/$1/;
      while( /\\$tag_name(\[[^{]*\])?{(([^}]*\/)?[^}/.]+($suffix))}/ ) {
         $matched_file = $2; 
         if( &array_index(@found_files, $matched_file) < 0 ) {
	    push(@found_files, $matched_file);
	 }
      }
   }
   
   close SOURCE_FILE;

   return @found_files;
}

### Build a list of all files which are included from the root file.
# This function recurses, and is maybe smart enough to detect cycles.
# Be sure to set FILES to the empty string prior to calling this.
# parameter 1: tex file to start with

sub get_file_list {
   local $source = $_[0];
   local @imports = ();

   # This is the cycle avoidance logic.
   if ( @array_index(@REF_DOCS, $source) < 0 ) {
      # Make sure the file can be accessed
      &check_file($source, "Included TeX file seems not to be available. Path problem?");

      # Save the argument in the list of files.
      push(@REF_DOCS, $source);

      # Get the list of files included by the argument.
      @imports=&extract_files($source, 'include|input', '(\.tex)?');

      # Recurse.
      foreach my $file (@imports) {
         if( ! $file =~ /\.tex$/ ) { $file .= '.tex'; }
         &get_file_list($file);
      }
   }
}

### Convert given tex file to the temp tex file we need for pdftex
### major task is to change the reference in the tex files to the
### corresponding tmp files
# parameter 1: tex source file
# parameter 2: tex tmp file
# parameter 3: adjust the LaTeX preamble (default: $NO)

sub convert_tex2tmp {
   my $source = $_[0];
   my $target = $_[1];
   my $adjust_preamble = ($_[2] == $YES) ? $YES : $NO;
   my $read_err_msg = "Could not read original TeX document to generate temporary document";
   
   ### open source and target file
   &check_file($source, $read_err_msg . '.');
   open(SOURCE_FILE, "<$source") or
      &abort($read_err_msg . " ($source).");

   open(TARGET_FILE, ">$target") or
      &abort("Could not open file to write temporary TeX document ($target).");
   
   ### set target file as stdout
   select TARGET_FILE;
   
   if ( $adjust_preamble eq $YES ) {
      ### read, parse, modify and write the LaTeX preamble
      while(<SOURCE_FILE>) {
   
         # protect pdflatex execution mode
         s/^(\\batchmode)$/% $1/
   
         # print the read line
         print $_;
   
         # append our extra TeX commands after the matching line
         if ( /&param_value('INSERT_REGEXP')/ ) {
            print '\usepackage{pslatex}' . "\n";
            
   	 if ( &param_value('THUMBNAILS') eq $YES ) {
               print '\usepackage{thumbpdf}' . "\n";
   	 } else {
   	    print "% no thumbpdf support\n";
   	 }
   	 
            print '\makeatletter' . "\n";
            print '\usepackage['. join(',', @HYPERREF_PARAMS) . ']{hyperref}' . "\n";
            print '\makeatother' . "\n";
         }
   
         # if end of the preamble is reached stop loop
         if ( /^\\begin\{document\}$/ ) { last; }
      }
   }
   
   ### read, parse, modify and write the TeX body
   while(<SOURCE_FILE>) {
      s/(\\includegraphics)(\[[^]]*\])?(\{[^}]+)\.(e?ps|pstex)\}/$1$2$3}/g
      s/(\\input\{[^}]+\.)pstex_t\}/$1pdf_t}/g
      s/(\\(input|include)\{[^}]+)(\.tex)?\}/$1&param_value('TMPBASESUFFIX')$3}/g

      # print the read and manipulted line
      print $_;
   }

   ### set STDOUT as stdout again
   select STDOUT;

   ### close files
   close SOURCE_FILE;
   close TARGET_FILE;
}

### Convert all given EPS images to PDF
# parameters ($@): list of EPS images with relative path to working directoy

sub convert_eps2pdf {
   my @image_list=@_;

   foreach my $image (@image_list) {
      my $image_path;
      my $image_base;
      my $image_name;
      my $suffix;
      my $image_target;

      ($image_base,$image_path,$suffix) = fileparse($image, ('\.eps', '\.ps', '\pstex'));
      $image_name = $image_base . $suffix;
      $image_target = $image_path . $image_base . '.pdf';
      
      #### check if image file really exists
      &check_file($image, "Could not convert referenced image.");

      if ( ! -f $image_target or -M $image_target > -M $image ) {
         print "Converting image $image_name ...\n";
         system("epstopdf", '-outfile='.$image_target, $image)
	    or &abort "epstopdf failed on $image_name: $!";
         push(@TMPFILES, $image_target);
      } else {
         print "$image_base.pdf newer than $image_name, conversion skipped...\n";
      }
   }
}

### Convert all given PSTEX_T files to PDF_T
# parameters ($@): list of PSTEX_T files with relative path to working directoy

sub convert_pstex2pdf {
   my @pstex_file_list = @_;

   foreach my $pstex_file (@pstex_file_list) {
      my $pstex_path;
      my $pstex_base;
      my $pstex_name;
      my $suffix;
      my $pstex_target;
      my @eps_images;

      ($pstex_base,$pstex_path,$suffix) = fileparse($pstex_file, ('\.pstex_t'));
      $pstex_name = $pstex_base . $suffix;
      $pstex_target = $pstex_path . $pstex_base . '.pdf_t';
      
      #### check if image file really exists
      &check_file($pstex_file, "Could not convert referenced file.");

      # descend into file
      print "Converting file $pstex_name ...\n";

      # find included EPS image(s)
      @eps_images=&extract_files($pstex_file, 'includegraphics', '\.pstex');

      # create .pdf_t file
      &convert_tex2tmp($pstex_file, $pstex_target, $NO); 

      # convert image(s) to pdf
      &convert_eps2pdf(@eps_images);

      push(@TMPFILES, $pstex_target);
   }
}

### Converted included images to pdf
# parameter ($1): tex source file

sub convert_images {
   my $tex_source="$_[0]";
   my @pstex_file_list;
   my @eps_image_list;

   print "\nConverting images referenced in $tex_source.\n";

   ##### Get EPS images from the source file
   print "\nScanning for EPS images (.eps/.ps):\n";
   @eps_image_list=&extract_files($tex_source, 'includegraphics', '\.e\?ps');
   if ( @eps_image_list > 0 ) {
      print "@eps_image_list\n";
   } else {
      print "None.\n";
   }

   ##### Get PSTEX_T files from the source file
   print "\nScanning for PSTEX_T files (.pstex_t):\n";
   @pstex_file_list=&extract_files($tex_source, 'input', '\.pstex_t');
   if ( @pstex_file_list > 0 ) {
      print "@pstex_file_list\n";
   } else {
      print "None.\n";
   }

   ### Convert all EPS images to PDF
   if ( @eps_image_list > 0) {
      print "\n$MYNAME: Converting EPS images to pdf\n";
      &convert_eps2pdf(@eps_image_list);
   }

   ### Convert all PSTEX_T files to PDF_T
   if ( @pstex_file_list > 0 ) { 
      print "\n$MYNAME: Converting pstex_t docs to pdf_t docs\n";
      &convert_pstex2pdf(@pstex_file_list);
   }

   print "\nFinished converting for ${tex_source}.\n";
}

#### Prepare the main document and all referenced ones for the generation
#### of the PDF document (including referenced images)
# parameter 1: top level tex document

sub prepare_documents {
   my $main_tex_doc=$_[0];
   my $main_tmp_doc = &get_tmp_filename($main_tex_doc);
   @REF_DOCS=();

   ##### Get the list of imported files from the tex file
   &get_file_list($main_tex_doc);
   
   ## remove main file from list (first element; needs special handling)
   shift @REF_DOCS;
   
   ## tell user about the identified refereneced docs
   if ( @REF_DOCS > 0 ) {
      print "\nFound the following referenced TeX files:\n";
      foreach my $file (@REF_DOCS) {
         print ">>>>> $file\n";
      }
   } else {
      print "\nFound no included TeX files.\n";
   }
   
   ##### Generate adjusted temp tex files and convert all their images
   ## main doc
   print "\n$MYNAME: Generating main temporary LaTeX document: $main_tmp_doc\n";
   &convert_tex2tmp($main_tex_doc, $main_tmp_doc, $YES);
   &convert_images($main_tex_doc);
   
   ## referenced docs
   foreach my $file (@REF_DOCS) {
      my $tmp_file = &get_tmp_filename($file);
   
      ### Insert pdf conversation tags in tex file and write it to tmp_file
      print "\n$MYNAME: Generating temporary LaTeX document: $tmp_file\n";
      &convert_tex2tmp($file, $tmp_file);
      &convert_images($file);
   }
}

### run pdflatex
# parameter $1: LaTeX file without extension
# parameter $2: log-file where the full out put is stored
# return value: 0 - no errors (no rerun); 1 - errors (rerun required)

sub run_pdflatex {
   my $texfile=$_[0];
   my $logfile=$_[1];
   my $errors=0;
   my $exit_status=0;
   my $extra_options=&param_value('pdftex-opts');
   
   print "Pdflatex is running. Please wait.\n\n";
   system("pdflatex --interaction nonstopmode $extra_options $texfile > $logfile");
   $exit_status=$?;
   print "Pdflatex finished. Errors:\n";
   $errors=`grep "! Emergency stop\|Error:\|LaTeX Warning:" $logfile | wc -l`;
   if ( $errors != 0 or $exit_status != 0 ) {
      if ( `grep '! Emergency stop' $logfile` ne "" ) {
         system('cat', $logfile);
	 print "\n";
	 &abort "Fatal error occured. I am lost.";
      }
      if ( $errors != 0 ) {
         system('grep','Error:\|LaTeX Warning:',$logfile);
      } else {
         system('tail',$logfile);
      }
      print "\n$MYNAME: See $logfile for details.\n";
      return 1;
   } else {
      print "None detected (log file: $logfile).\n";
      return 0;
   }
}

#### run bibtex if BIBTEX=$YES or a bibliography tag is found
# included tex files are not parsed for a bibliography
# parameter 1: filename of the aux file without .aux suffix
# parameter 2: log-file where the full out put is stored

sub handle_bibtex  {
   my $auxfile=$_[0];
   my $logfile=$_[1];
   my $run_bibtex=$FALSE;
   my $bibtex_param=&param_value('bibtex');
   
   print "\n";
   if ( $bibtex_param eq $YES ) {
      $run_bibtex=$TRUE;
      print "$MYNAME: BibTeX paramter set to '$YES'; running BibTeX.\n";
   } else {
      print "$MYNAME: Checking for BibTeX bibliography in document.\n";
      if(`grep "^[^%]*[\]bibliography{" $auxfile.tex` ne "") {
         $run_bibtex=$TRUE;
	 print "Bibliography detected; running BibTeX.\n";
      } else {
         print "No bibliography detected.\n";
      }
   }
   if ( $run_bibtex ) {
      system "bibtex $auxfile > $logfile";
      if (! $? or `grep "error message" $logfile` ne "" ) {
         print "\n****************** BibTeX errors reported *******************\n";
         system('cat', $logfile);
         print "*************************************************************\n";
         print "\n$MYNAME: You can switch off BibTeX support by setting the bibtex parameter to $NO.\n";
      } else {
         print "BibTeX finished without errors.\n";
      }
   }
}

#### run thumbpdf command to make thumbnails
# more informations: /usr/share/texmf/doc/pdftex/thumbpdf/readme.txt
# parameter 1: LaTeX file without extension
# parameter 2: log-file where the full out put is stored

sub run_thumbpdf {
   my $texfile=$_[0];
   my $logfile=$_[1];
   my $exit_status=0;
   #local $TEXFILE=$_[0];

   print "\n$MYNAME: Creating thumbnails with 'thumbpdf'\n\n";
   system('thumbpdf', $texfile);
   $exit_status=$?;
   if ( $exit_status != 0 ) {
      print "\n$MYNAME: thumbpdf exit with status $exit_status.\n";
      print "I will continue, but maybe there will not be thumbs in the PDF doc.\n";
   }

   if ( -f thumbpdf.log ) {
      rename('thumbpdf.log', $logfile);
      print "\n$MYNAME: See $logfile for details.\n";
   }

   push (@TMPFILES, glob 'thumb???.png');
   if ( -f "thumbpdf.pdf" ) { push (@TMPFILES, 'thumbpdf.pdf'); }
   if ( -f "thumbdta.tex" ) { push(@TMPFILES, 'thumbdta.tex'); }
}

##### Generate the final PDF document
# parameter 1: filename of the LaTeX document (with extension)

sub generate_pdf_doc {
   my $tex_doc = $_[0];
   my $index_file;
   my $runno=1;
   my $rerun=$TRUE;
   my $pdflog_base = $PDFLOGBASE; #FIXME
   my $bibtex_log = $BIBTEXLOG;   #FIXME
   my $thumbpdf_log = $THUMBPDFLOG;   #FIXME

   ### cut of .tex extension - pdflatex does not like it
   $tex_doc =~ s/\.tex$//;
   $index_file = $tex_doc.'.idx';
   
   ### run pdflatex until no more errors are reported (max MAXRUNNO)
   while ( $rerun == $TRUE and $runno <= &param_value('maxrun') )
   {
      print "\n************ Pdflatex run no. $runno *************\n";
      if ( &run_pdflatex($tex_doc, $pdflog_base.$runno.'.log') == $TRUE 
         and ( &param_value('minrun') <= $runno )) {
         # no errors detected and MINRUNNO is processed
         $rerun=$FALSE;
      } else {
         # errors appeared or MINRUNNO has not been reached
         $rerun=$TRUE;
      }
   
      ### Execute BibTeX after first run if set (and required)
      if ( $runno == 1 and &param_value('bibtex') ne $NO ) {
         &handle_bibtex($tex_doc, $bibtex_log);
      }
   
      $runno += 1;
   }
   
   $rerun = $FALSE;
   
   ### if the THUMBNAILS option is switched on then make thumbnails
   if ( &param_value('thumbpdf') eq $YES ) {
      &run_thumbpdf($tex_doc, $thumbpdf_log);
      $rerun=$TRUE;
   }
   
   ### generate index if required
   if ( -f $index_file and &param_value('forceindex') ne $NO ) {
      print "\n$MYNAME: Document seems to have an index. Generating ...\n\n";
      &makeindex($index_file);
      $rerun=$TRUE;
   }
   
   ### One final pdflatex run if requested
   if ( $rerun ) {
      print "\n************ One final pdflatex run no. $runno *************\n";
      &run_pdflatex($tex_doc, $pdflog_base.$runno.'.log');
   }
}
   
################## Lift off !!!! (main part) ##################
$TMPBASE=;
@TMPFILES=();
$TITLE=;
$AUTHOR=;

my $hyperref_params;
my $texdoc;
my $pdf_path;

print "\n$MYNAME: Script starts (Release $MYRELEASE)\n";

##### read and analyse configuration and options and adjust basic variables
##### accordingly
##### write RC file on config request

print "\n$MYNAME: Processing given parameters and arguments.\n";
&adjust_configuration(@_);

#### use the finished configuration to get all further settings before we
#### actually start doing something

print "\n$MYNAME: Doing some tests.\n";
&do_basic_test;

#### prepare the script to write some information to specified log files

print "\n$MYNAME: Preparing log files.\n";
&prepare_logfiles;

#### process the one and only argument (besides the options) which specifies
#### which LaTeX document the user wants to translate to PDF
#### a lyx file will be translated to LaTeX first

print "\n$MYNAME: Analysing your document argument.\n";
&process_doc_argument;

#### we would like to get some more information from the actual
#### main LaTeX document before we really start
#### parse the document and try to get the info

## translate hyperref settings to the actual package parameters 
   
print "\n$MYNAME: Setting up parameters for hyperref.\n";
@hyperref_params = &generate_hyperref_params($texdoc);

## set the working dir to the input path if the document has one and
## determine the path for the result

print "\n$MYNAME: Setting the correct path for the result.\n";
$pdf_path = &get_pdf_path($texdoc);
   
## as much as possible is prepared in advance at this point
## so hopefully we will succeed in generating the PDF document

##### real work starts NOW

##### Generate adjusted temp tex files and convert all their images

print "\n$MYNAME: Preparing all documents and images.\n";
&prepare_documents($texdoc);

##### Generate the final PDF document

print "\n$MYNAME: Processing the actual generation of the PDF document.\n";
&generate_pdf_doc($texdoc);

##### Clean up
if ( ! -f $TMPBASE.'.pdf' ) {
   print "\n";
   &abort "The PDF file $TMPBASE.pdf was not generated.";
}

rename($TMPBASE.'.pdf', $pdf_path.$DOCBASE.'.pdf');
print "\n";
&clean_up;
print "\nThe new pdf file is: ${PDFOUTDIR}${DOCBASE}.pdf\n\n";

