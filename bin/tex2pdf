#!/usr/bin/perl -w

#      tex2pdf - script for translating latex docs to pdf
#
#      Copyright (C) 2000,2001 by Steffen Evers
#
#      This program is free software; you can redistribute it and/or modify
#      it under the terms of the GNU General Public License version 2 as 
#      published by the Free Software Foundation.
#
#      This program is distributed in the hope that it will be useful,
#      but WITHOUT ANY WARRANTY; without even the implied warranty of
#      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#      GNU General Public License for more details.
#
#      You should have received a copy of the GNU General Public License
#      along with this program; if not, write to the Free Software
#      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#      The GNU General Public License is also available online:
#      http://www.gnu.org/licenses/gpl.html
#
# Thanks a lot to all the people that have already contributed to this project!
#
# The changelog including the credits has become too long. So, I have removed it
# from the script, but it is still available online (see below). 
#
# Special thanks to the following people for their contribution
# (see the changelog for details):
# Matej Cepl, Herbert Voss, Nicolas Marsgui, Bruce Foster, Mark van Rossum,
# Matt Bandy, Garrick Chien Welsh, Stacy J. Prowell, Pavel Sedivy,
# Holger Daszler, Olaf Gabler, Ahmet Sekercioglui, Richard, Steffen Macke
#
# Project Homepage: http://tex2pdf.berlios.de
# Developer Homepage: http://developer.berlios.de/projects/tex2pdf
# Mailing lists: http://developer.berlios.de/mail/?group_id=57
# Changelog: http://tex2pdf.berlios.de/changelog.html
#
# Anyone is invited to help to improve tex2pdf. Therefore any kind of feedback
# is welcome. Maybe you even would like to hack the code and send us your
# changes. This would help a lot and is highly appreciated. Think about it :-)
# Subscribing to the developer mailing list might be a first step (see above).
#
# Send feedback to: tex2pdf-devel@lists.berlios.de
#

$MYRELEASE="2.2.8pl";

##### You will need pdftex and epstopdf for the generation!
##### See pdftex homepage for details: http://tug.org/applications/pdftex/
##### Have fun!!!

##### Default parameters
## Change the parameters below if you want to change the default settings for
## all users.  If you only want to change your private parameters change them
## in the RC_FILENAME

### text token for no value
$NIL="NOVALUE";

### text token for boolean 'no' 
$NO="no";

### text token for boolean 'yes' 
$YES="yes";

### pdftex package options:
### see hyperref manual for more:/usr/share/texmf/doc/latex/hyperref/manual.pdf

# possible paper sizes
# this list MUST have the syntax "PAPER1 PAPER2 ..."
@POSSIBLE_PAPER = (qw< a4paper letterpaper legalpaper executivepaper >, $NIL);

# papersize of the resulting pdf document
$PAPERSIZE="a4paper";

# use color for links in the resulting document
# options: 'yes' or 'no'
$COLORLINKS=$YES;

# possible link colors
# this list MUST have the syntax "COLOR1 COLOR2 ..."
@LINK_COLORS= (qw< yellow red green cyan blue magenta black >, $NIL);

# color to use for page links in resulting document
# some possible values: see above
# set to $NIL for default value
$PAGECOLOR="magenta";

# color to use for regular internal links in resulting document
# some possible values: see above
# set to $NIL for default value
$LINKCOLOR="green";

# color to use for URLS in resulting document
# some possible values: see above
# set to $NIL for default value
$URLCOLOR="blue";

# color to use for citations in resulting document
# some possible values: see above
# set to $NIL for default value
$CITECOLOR="red";

# Default title for document info in the resulting PDF 
# leave blank for default value
$DEFAULT_TITLE=$NIL;

# Default author for document info in the resulting PDF 
# leave blank for default value
$DEFAULT_AUTHOR=$NIL;

# additional parameters for hyperref package
# format: PARAMETERNAME={VALUE},PARAMETERNAME={VALUE},...
# leave blank for no additional values
$ADDITIONAL_PARAMETERS="";

# link tabel of contents to pages instead of sections
# sets linktocpage
$LINKTOCPAGE=$YES;

### other parameters

# place where generated pdf file is stored:
# source_dir - same directory as the LaTeX file
# input_dir  - same directory as the input files of the LaTeX file
# custom     - specified directory PDFCUSTOMDIR
@POSSIBLE_PDFOUT= qw< source_dir input_dir custom >;
$PDFOUT = $POSSIBLE_PDFOUT[0];

# custom directory where the generated pdf file is stored
$PDFCUSTOMDIR=$ENV{'HOME'};

# usage of bibtex
# possible values: 'yes' (always run bibtex), 'no' (never run bibtex),
# 'test' (scan tex file for a bibtex entry and run it if required)
@POSSIBLE_BIBTEX= ($YES, $NO, "test");
$BIBTEX="test";

# maximal number of runs for pdflatex
$MAXRUNNO=6;

# minimal number of runs for pdflatex
# This option can be used to force pdflatex to run at least MINRUNNO times even
# when tex2pdf cannot detect any more warnings or errors.
# This might help if there is no table of contents or other things are missing.
# possible values: 1 ... MAXRUNNO
$MINRUNNO=2;

# directory for log files
$LOGDIR="/tmp/tex2pdf-$ENV{'USER'}/";

# clean log files before execution
# You might get problems with this when you run tex2pdf on several documents
# at the same time. So, if you want to be on the safe side set "no" and clean
# the log directory manually.
# possible values: 'yes', 'no'
$CLEANLOGS=$NO;

# Use which command to check for required executables
# possible values: 'yes', 'no'
$COMMANDCHECK=$YES;

# use thumbpdf to include thumbnails of all PDF document pages
# requires ghostscript version 5.50 or higher to generate the thumbnails (PNG)
# see more informations: /usr/share/texmf/doc/pdftex/thumbpdf/readme.txt
# possible values: "yes" for thumbnails, "no" - without thumbnails
$THUMBNAILS=$NO;

# execution of the makeindex command for index handling
# this should fix the problem with a missing document index
# possible values: "yes" - check for index file and if found call makeindex
#                  "no"  - never execute it
$MAKEINDEX=$YES;

##### expert parameters
## the following parameters should NOT be modified by regular users!
## study the script carefully before you change them !!!

# the sed executable this script should use for the configuration part
# simply 'sed' means script should use the sed in your path
$SEDCMD="sed";

# the sed executable this script should use for the parsing
# simply 'sed' means script should use the sed in your path
$SEDEXE="sed";

# additional options for pdflatex
$PDFTEXOPTS="";

# suffix for tmp files that will be put in between the basename and suffix of
# the original file
# CAUTION: If you leave this blank you will overwrite the original files!
$TMPBASESUFFIX="-pdf";

# remove all tmp files on abort
$CLEAN_ON_ABORT=$NO;

# sed command which is used to insert additional TeX commands in the LaTeX
# preamble
# try the following commands if you have strange errors or junk on the
# first PDF document page
# INSERTCOMMAND="/^[\]begin{document}$/i"
# INSERTCOMMAND="/^[\]makeatletter$/i"
$INSERTCOMMAND='/^[\]documentclass\(\[[^]]*\]\)\?{.*}/a';

### file to store private parameters
# If you only want to change your private parameters change them there
# default: $HOME/.tex2pdfrc
$RC_FILENAME="$ENV{'HOME'}/.tex2pdfrc";

# variables for the rc file
# list of all variables that should be stored/read in/from the rc file
# this list MUST have the syntax "VARIABLE1 VARIABLE2 ..."
@RC_VARIABLES= qw< PAPERSIZE COLORLINKS PAGECOLOR LINKCOLOR URLCOLOR CITECOLOR
   DEFAULT_TITLE DEFAULT_AUTHOR LINKTOCPAGE ADDITIONAL_PARAMETERS PDFOUT
   PDFCUSTOMDIR SEDEXE BIBTEX MAXRUNNO MINRUNNO LOGDIR CLEANLOGS PDFTEXOPTS
   COMMANDCHECK THUMBNAILS TMPBASESUFFIX MAKEINDEX INSERTCOMMAND >;

##### Functions ###########################################

### Removing all temporary files

sub clean_up {
   print "$MYNAME: Removing temporary files ...\n";
   if ( $TMPFILES ) { unlink glob $TMPFILES; }
   if ( $TMPBASE ) { unlink glob "$TMPBASE.*"; }
}

###  exit with an error message

sub abort {
   print "$MYNAME: @_\n";
   if ( $CLEAN_ON_ABORT eq $YES ) { clean_up; }
   print "Aborting ...\n";
   exit 1;
}

#### General functions (not script specific)

### interactively answer a question with yes or no
# $1 question
# $2 default value

sub questionYN {
   my $user_input;
   my $default;
   $RESPONSE="";
   while ( $RESPONSE eq "" ) {
      if ( $_[1] eq $YES ) {
         print "$_[0] [y]";
         $default=$YES;
      } else {
         print "$_[0] [n]";
         $default=$NO;
      }
      $user_input = <STDIN>;
      chomp($user_input);
      
      if( $user_input =~ /^[yY]([Ee][Ss])?/ ) {
         $RESPONSE=$YES;
      } elsif ( $user_input =~ /^[Nn][Oo]?/ ) {
         $RESPONSE=$NO;
      } elsif ( $user_input eq "" ) {
         $RESPONSE=$default;
      } else {
         print "Please respond with y or n.\n";
      }
   }
}

### interactively input a positive integer number
# $1 question
# $2 default value
# $3 min value
# $4 max value
# $RESPONSE: the input number

sub input_number {
   my $user_input;
   my $question = $_[0];
   my $default = $_[1];
   my $min_limit = $_[2];
   my $max_limit = $_[3];
   $RESPONSE="";

   while ( $RESPONSE eq "" ) {
      print "$question [$default]: ";
      $user_input = <STDIN>;
      chomp($user_input);
      
      if ( $user_input eq "" ) {
         $RESPONSE=$_[1];
      } else {
         $_ = $user_input;
         if (s/^([[:digit:]]+)$/$1/ and $_ >= $min_limit and $_ <= $max_limit ) {
            $RESPONSE = $_;
	 } else {
            print "Invalid input. Please enter a positve integer from $min_limit to $max_limit.\n";
         }
      }
   }
}

### interactively choose between several given values
# $1 question
# $2 default value
# $3 ... $x possible values
# $RESPONSE chosen value

sub chooseValue {
   my $question=$_[0];
   my $default=$_[1];
   my $list_index=1;
   my $default_no=1;

   shift @_;
   shift @_;

   print "$question\n";
   foreach (@_)
   {
      print "$list_index) $_\n";
      if ( $default eq $_ ) { $default_no=$list_index; }
      $list_index = $list_index + 1;
   }

   &input_number("Please enter the corresponding number", $default_no, 1, scalar @_);
   $RESPONSE = $_[$RESPONSE - 1 ];
}

### interactively answer a question
# $1: question
# $2: current value

sub input_text {
   my $user_input;

   print "Suggested value: $_[1]\n";
   questionYN("Do you want to keep this value?", $YES);
   if ( $RESPONSE eq $YES ) {
      $RESPONSE="$_[1]";
   } else {
      print "$_[0] ";
      $user_input = <STDIN>;
      chomp($user_input);
      
      $RESPONSE = $user_input;
   }
}

##### Make sure that specified file exists and is readable; abort if missing
# parameter $1: file to check
# parameter $2: remark if check fails on specified file

sub check_file {
   my $file = $_[0];
   my $message = defined($_[1]) ? $_[1] : "Required file cannot be accessed!";

   if ( ! -f $file ) {
      print "\n";
      print "$MYNAME: Sorry. I cannot find '$file'.\n";
      &abort($message);
   } elsif ( ! -r $file ) {
      print "\n";
      print "$MYNAME: Sorry. File '$file' exists, but is not readable.\n";
      &abort($message);
   }
}

##### Make sure that specified directory exists and is writable
# return values: 0 - ok; 1 - error
# parameter $1: directory to check
# parameter $2: remark if check fails on specified directory
# paramter $3: if yes, creation is allowed

sub check_dir {
   my $directory = $_[0];
   my $message = defined($_[1]) ? $_[1] : "Not a valid path!";
   my $allow_creation = defined($_[2]) ? $_[2] : $NO;

   if ( index($directory, "/") != 0 ) {
      print "\n";
      print "$MYNAME: Sorry. '$directory' is not an absolute path.\n";
      print "$message\n";
      return 1;
   } elsif ( ! -d $directory ) {
      # dir does not exist
      print "\n";
      if ( $allow_creation eq $YES ) {
         # creation allowed
         print "$MYNAME: I cannot find '$directory'. Try to create it.\n";
	 if ( mkdir($directory, 0755) ) {
	    print "Creation of '$directory' was successful.\n";
	    return 0;
	 } else {
	    print "$MYNAME: Creation of '$directory' failed.\n";
	    print "$message\n";
	    return 1;
	 }
      } else {
         # creation not allowed
         print "$MYNAME: Sorry. Directory '$directory' does not exist.\n";
         print "$message\n";
         return 1;
      }
   } elsif ( ! -w $directory ) {
      # dir not writable
      print "\n";
      print "$MYNAME: Sorry. Directory '$directory' exists, but is not writable.\n";
      print "$message\n";
      return 1;
   }
   return 0;
}

### interactively input an directory for data storage (absolute path)
# $1 question
# $2 default dir
# $3 if 'yes' allow creation of directory
# $RESPONSE: the given directory 

sub input_dir {
   my $question = $_[0];
   my $default_dir = $_[1];
   my $allow_creation = defined($_[2]) ? $_[2] : $NO;
   my $user_input;
   $RESPONSE = "";

   if ( defined($default_dir) and index($default_dir, "/") == 0 
        and ( (! -d $default_dir and $allow_creation eq $YES) 
        or (-d $default_dir and -w $default_dir) ) ) {
      $question .= " [$default_dir]: ";
   } else {
      $default_dir = undef;
      $question .= ": ";
   }

   while ( $RESPONSE eq "" ) {
      print "$question";
      $user_input = <STDIN>;
      chomp($user_input);
      
      if( $user_input eq "" and defined($default_dir) ) {
         # user has only pressed <ENTER> and thereby confirmed default value
	 if( &check_dir("$default_dir","Default value was not valid. Please, give different directory.", $allow_creation ) != 0 ) {
	    # default dir does not exist and cannot be created
	    $default_dir = undef;
	    $question = "$_[0]: ";
	 } else {
	    # valid default dir has already existed or has been created
            $RESPONSE = $default_dir;
	 }
      } else {
         # user has given a directory
         if( &check_dir($user_input,"This is not a valid directory!", $allow_creation) == 0 ) {
	    $RESPONSE = $user_input;
         }
      }
   }
}

### set a variable by a command line option to 'yes' or' no'; abort on error
# $1 variable
# $2 given value
# $3 option letter

sub setYNValue {
   my $variable = $_[0];
   my $argument = $_[1];
   my $option_letter = $_[2];

   if( $argument =~ /^[yY]([Ee][Ss])?/ ) {
      $$variable = $YES;
   } elsif ( $argument =~ /^[Nn][Oo]?/ ) {
      $$variable = $NO;
   } else {
      print "\n";
      print "$variable requires '$YES' or '$NO'." ;
      &abort("Illegal argument for option -$option_letter: $argument");
   }
}

### set a variable by a command line option to a possible values; abort on error
# $1 variable
# $2 given value
# $3 option letter
# $4 list of possible values

sub setValue {
   my $variable = $_[0];
   my $argument = $_[1];
   my $option_letter = $_[2];

   shift @_;
   shift @_;
   shift @_;

   my @possible_values = @_;

   if ( index("@possible_values", $argument) < 0 ) {
      print "\n";
      print "$variable allows: @possible_values.\n";
      &abort("Illegal argument for option -$option_letter: $argument");
      exit 1;
   }
   $$variable = $argument;
}

### Check for required command with 'which'; abort if not found
# parameter $1: command to check
# parameter $2: remark if specified command is not found

sub checkCommand {
   my $command = $_[0];
   my $message = $_[1];

   $_ = `which $command 2>&1`; 
   chomp;
   s|^(.*/)?([^/]+)$|$2|;

   if ( $_ ne $command ) {
      print "\n";
      system "which", $command;
      print "\n";
      print "$MYNAME: Required command '$command' seems not to be in your path.\n";
      if ( defined($message) ) {
         print "$message\n";
      }
      print "Aborting ...\n";
      exit 1;
   }
}

### save configuration in rc file

sub write_configuration {
   my $date;
   open(RCFILE, ">$RC_FILENAME") or
      &abort("Could not open configuration file for writing ($RC_FILENAME)");
   select RCFILE;

   $date = `date`;
   chomp($date);
   
   print "# Configuration file for $MYNAME V$MYRELEASE\n";
   print "# Generated $date by $ENV{'USER'} on $ENV{'HOSTNAME'}\n";
   
   foreach my $variable (@RC_VARIABLES) {
      print "$variable".'='."$$variable\n";
   }
   
   print "# EOF\n";
   select STDOUT;
   close RCFILE;
}

### print the configuration parameters
sub print_configuration {
   print "Configuration for $MYNAME V$MYRELEASE\n";
   
   foreach my $variable (@RC_VARIABLES) {
      print "$variable".'='."$$variable\n";
   }
   
   print "\n";
}

### load parameters from rc file

sub read_configuration {
   my $line;

   &check_file($RC_FILENAME, "Could not access configuration file");
   open(RCFILE, "<$RC_FILENAME") or
      &abort("Could not open configuration file for reading ($RC_FILENAME)");

   while (defined($line = <RCFILE>)) {
      foreach my $parameter (@RC_VARIABLES) {
         $_ = $line;
         chomp;
         if( s/^$parameter=([[:print:]]*)$/$1/ ) {
            $$parameter = $_; 
         }
      }
   }
   close RCFILE;
}

###################### Specific functions (for use with this script only)

### print usage of command

sub usage {
   print "\n";
   print "Usage: $MYNAME [OPTIONS] DOCUMENT.lyx\n";
   print "       $MYNAME [OPTIONS] DOCUMENT.tex\n";
   print "       $MYNAME [-h|-v|-o|-r]\n";
   print "\n";
}

### print command help

sub help {
   print "\n";
   print "$MYNAME Version $MYRELEASE\n";
   @usage;
   print " -h : print this message\n";
   print " -v : print version information\n";
   print " -o : print configuration parameters\n";
   print " -r : run configure parameters\n";
   print "\n";
   print " -i BOOL   : makeindex\n";
   print " -l BOOL   : clean log files\n";
   print " -c BOOL   : check for required commands\n";
   print " -n BOOL   : generate thumbnails for PDF document\n";
   print " -t TITLE  : specify title for PDF document info\n";
   print " -a AUTHOR : specify author for PDF document info\n";
   print " -p SELECT : select papersize: @POSSIBLE_PAPER\n";
   print " -b SELECT : select bibtex handling: @POSSIBLE_BIBTEX\n";
   print " -d PATH   : custom directory where the final PDF is stored\n";
   print "\n";
}

### print script version

sub print_version   {
   print "\n";
   print "$MYNAME Version $MYRELEASE\n";
   print "\n";
}

### Check number of arguments
# parameters ($@): all arguments that were passed to the script by the shell

sub check_arguments  {
   if ( @_ == 0 ) {
      print "\n";
      print "$MYNAME: I need at least one argument!\n";
      @usage;
      exit 1;
   }
}

### configure tex2pdf parameters interactively

sub configure  {
   print "\n";
   print "Configuration for tex2pdf.\n";
   print "The following answers are considered as defaults in later executions\n";
   print "of $MYNAME. You can change these values by using option -r.\n";
   print "The command-line options override these settings.\n";
   print "Many parameters can be set to '$NIL'. This means that NO value at\n";
   print "all (not even an empty value) is passed over to the called\n";
   print "application (e.g. latex package hyperref).\n";
   print "\n";

   print "----------------\n";
   print "$MYNAME can set the papersize of the resulting PDF document.\n";
   &chooseValue("What papersize should be used?",$PAPERSIZE,@POSSIBLE_PAPER);
   $PAPERSIZE=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "The table of contents of the resulting PDF document is normally linked\n";
   print "to the corresponding section. However, you can also link it to the\n";
   print "corresponding page instead.\n";
   &questionYN("Should TOC be linked to pages?",$LINKTOCPAGE);
   $LINKTOCPAGE=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "$MYNAME can use different colors for links inside the PDF document.\n";
   &questionYN("Should colors be used for links?",$COLORLINKS);
   $COLORLINKS=$RESPONSE;
   print "\n";

   if ( $COLORLINKS eq $YES ) {
        print "----------------\n";
        print "It is possible to specify the color for page links.\n";
        &chooseValue("What color should be used for page links?",$PAGECOLOR,@LINK_COLORS);
        $PAGECOLOR=$RESPONSE;
        print "\n";

        print "----------------\n";
        print "It is possible to specify the color for normal internal links.\n";
        &chooseValue("What color should be used for normal links?",$LINKCOLOR,@LINK_COLORS);
        $LINKCOLOR=$RESPONSE;
        print "\n";

        print "----------------\n";
        print "It is possible to specify the URL color.\n";
        &chooseValue("What color should be used for URLs?",$URLCOLOR,@LINK_COLORS);
        $URLCOLOR=$RESPONSE;
        print "\n";

        print "----------------\n";
        print "It is possible to specify the citation color.\n";
        &chooseValue("What color should be used for citation?",$CITECOLOR,@LINK_COLORS);
        $CITECOLOR=$RESPONSE;
        print "\n";
   }

   print "----------------\n";
   print "A PDF document contains meta data about itself: the document info.\n";
   print "Two of the info fields (title, author) can be set here as default\n";
   print "value which will be used in the case that $MYNAME cannot determine\n";
   print "proper settings from the LaTeX document.\n";
   print "\n";

   print "The default title for the document info of all generated documents.\n";
   print "$NIL will be recognized.\n";
   print "\n";
   &input_text("Default document title?",$DEFAULT_TITLE);
   $DEFAULT_TITLE=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "The default author for the document info of all generated documents.\n";
   print "$NIL will be recognized.\n";
   print "\n";
   &input_text("Default document author?",$DEFAULT_AUTHOR);
   $DEFAULT_AUTHOR=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "If you like you can make me pass additional parameters to hyperref.\n";
   print "See the hyperref manual for possible values and details.\n";
   print "These parameters should normally have the format:\n";
   print "PARAMETERNAME={VALUE},PARAMETERNAME={VALUE},...\n";
   print "Leave blank for no additional values.\n";
   print "\n";
   &input_text("Additional parameters ?",$ADDITIONAL_PARAMETERS);
   $ADDITIONAL_PARAMETERS=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "You can now specify in which directory the resulting document should\n";
   print "be written by default:\n";
   print "- '$POSSIBLE_PDFOUT[0]' means the same directory as the LaTeX file.\n";
   print "- '$POSSIBLE_PDFOUT[1]' means the same directory as the input files of your\n";
   print "  LaTeX file (e.g. images, included documents, etc.).\n";
   print "  This path should be specified in the source LaTeX document otherwise\n";
   print "  it is identical with the '$POSSIBLE_PDFOUT[0]' option.\n";
   print "- '$POSSIBLE_PDFOUT[2]' means you want to specify your own directory where the\n";
   print "  generated document should be written.\n";
   &chooseValue("Which output directory?",$PDFOUT,@POSSIBLE_PDFOUT);
   $PDFOUT=$RESPONSE;
   print "\n";

   if ( $PDFOUT eq $POSSIBLE_PDFOUT[2] ) {
      print "----------------\n";
      print "You have choosen to specifiy a custom output directory.\n";
      &input_dir("What custom directory should be used?",$PDFCUSTOMDIR,$YES);
      $PDFCUSTOMDIR=$RESPONSE;
      print "\n";
   }

   print "----------------\n";
   print "The sed executable to use can be specified.\n";
   print "Type 'sed' in order to use the sed in your path.\n";
   print "\n";
   &input_text("What sed executable should be used?",$SEDEXE);
   $SEDEXE=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "The bibtex usage can be specified.\n";
   print "Possible values are: '$POSSIBLE_BIBTEX[0]' (always run bibtex), '$POSSIBLE_BIBTEX[1]' (never run\n";
   print "bibtex) and '$POSSIBLE_BIBTEX[3]' (scan tex file for a bibtex entry and run it\n";
   print "if required).\n";
   &chooseValue("How should bibtex be used?",$BIBTEX,@POSSIBLE_BIBTEX);
   $BIBTEX=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "The maximal number of runs for pdflatex can be specified.\n";
   &input_number("What should be the maximum number of runs for pdflatex?",$MAXRUNNO 1 9);
   $MAXRUNNO=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "The minimal number of runs for pdflatex can be specified.\n";
   print "Possible values are: 1 ... $MAXRUNNO.\n";
   &input_number("What should be the minimum number of runs for pdflatex?",$MINRUNNO,1,$MAXRUNNO);
   $MINRUNNO=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "The log directory is used to store information about the generation\n";
   print "process for later review, e.g. for debugging.\n";
   &input_dir("What log directory should be used?",$LOGDIR,$YES);
   $LOGDIR=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "$MYNAME can clean the log files before execution.\n";
   print "You might experience problems if you run $MYNAME on several documents\n";
   print "the same time. If you want to be on the safe side, answer '$NO'.\n";
   &questionYN("Should the log files be cleaned before execution?",$CLEANLOGS);
   $CLEANLOGS=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "$MYNAME can check for the required executables.\n";
   &questionYN("Should $MYNAME check for the required executables?",$COMMANDCHECK);
   $COMMANDCHECK=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "$MYNAME can use thumbpdf to include thumbnails of the document pages.\n";
   print "This requires Ghostscript 5.50 or higher.\n";
   &questionYN("Should PNG thumbnails be created?",$THUMBNAILS);
   $THUMBNAILS=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "$MYNAME can force the call of makeindex if pdftex fails to do this.\n";
   &questionYN("Should the call of makeindex be forced?",$MAKEINDEX);
   $MAKEINDEX=$RESPONSE;
   print "\n";

   print "----------------\n";
   print "Additional options for pdflatex can be specified.\n";
   print "Normally, you can leave this blank.\n";
   print "\n";
   &input_text("What additional options for pdflatex should be used? :", $PDFTEXOPTS);
   $PDFTEXOPTS=$RESPONSE;
   print "\n";
}

### check if the most important executables are installed on the system
# parameters: none

sub check_commands {
   ### check for which command
   checkCommand which "You can switch off all command checks by setting $COMMANDCHECK=$NO in the parameter section of $MYNAME.";

   ### sed executable
   # GNU sed version 3.02 or higher is recommended
   # Download: ftp://ftp.gnu.org/pub/gnu/sed
   if ( $SEDEXE eq "sed" ) {
      checkCommand sed "You should get GNU sed 3.02 or later: ftp://ftp.gnu.org/pub/gnu/sed";
   }

   ### pdftex executables
   # Homepage: http://tug.org/applications/pdftex
   checkCommand pdflatex "See pdftex homepage for details: http://tug.org/applications/pdftex";
   checkCommand epstopdf "See pdftex homepage for details: http://tug.org/applications/pdftex";

   if ( $THUMBNAILS eq $YES ) {
      checkCommand thumbpdf "You can switch off thumbpdf support by setting $THUMBNAILS=$NO in the parameter section of $MYNAME.";
   }

   ### bibtex executable
   if ( $BIBTEX ne $NO ) {
      checkCommand bibtex "You can switch off BibTeX support by setting $BIBTEX=$NO in the parameter section of $MYNAME.";
   }
}

### generate LaTeX file from LyX document with LyX itself
# parameter ($1): Lyx document
# parameter ($2): Latex document

sub generate_tex_file  {
   local $LYXDOC=$_[0];
   local $TEXDOC=$_[1];

   ### Check if LyX file can be accessed
   check_file $LYXDOC "Cannot read the specified LyX document!";

   ### Check if LaTeX file exists and is newer than the LyX file
   if ( -f $TEXDOC and $TEXDOC -nt $LYXDOC ) {
      print "\n";
      print "$MYNAME: LaTeX file is newer than LyX document '$LYXDOC'.\n";
      print "Using existing TeX file: $TEXDOC\n";
      print "Remove it to force its new generation.\n";
   } else {
      ### export LaTeX file with LyX (needs a display!)
      checkCommand lyx "Cannot generate LaTeX document without LyX!";
      print "\n";
      print "$MYNAME: Exporting LaTeX file\n";
      if ( -f $HOME/.lyx/lyxpipe.out ) { mv $HOME/.lyx/lyxpipe.out $HOME/.lyx/lyxpipe.out~; }
      if ( -f $HOME/.lyx/lyxpipe.in ) { mv $HOME/.lyx/lyxpipe.in $HOME/.lyx/lyxpipe.in~; }
      if ( -f $TEXDOC ) { mv $TEXDOC $TEXDOC~; }
      lyx --export latex $LYXDOC;

      ### check if LaTeX file now really exists
      check_file $TEXDOC "The LaTeX document was not generated by LyX!";
   }
}

#### search for filenames in given TeX Tag in entire document
### skip all comments and duplicates while parsing
# parameter ($1): file to parse
# parameter ($2): full TeX tag name
# parameter ($3): regular expression for the filname suffix (including '.')
# $FOUND_FILES: result

sub extract_files  {
   local $SOURCE=$_[0];
   local $TAGNAME=$_[1];
   local $SUFFIX=$3;
   local $FILES=;
   $FOUND_FILES=;

   $FOUND_FILES=`sed -n -e "s/\(^\|[^\]\)%.*$/\1/" \;
     -e "s/^.*[\]\($TAGNAME\)\(\[[^{]*\]\)\?{\(\([^}]*\/\)\?[^}/.]\+\($SUFFIX\)\)}.*$/\3/p" $SOURCE`;

   if ( $FILES ) {
      for $i ($FILES);
      {
         if ( `echo $FOUND_FILES | ${SEDEXE} -n "\| $i\( \|$\)|p"` ) {
	    $FOUND_FILES="$FOUND_FILES $i";
	 }
      }
   }
}

### Build a list of all files which are included from the root file.
# This function recurses, and is maybe smart enough to detect cycles.
# One input parameter for this ($1): a tex file.
# Be sure to set FILES to the empty string prior to calling this.

sub getFileList  {
   local $IMPORTS=;

   # This is the cycle avoidance logic.
   $FILES=`echo $FILES | ${SEDEXE} -n "\| $_[0]|p`; 
   if ( ! "$flag" ) {
      # Make sure the file can be accessed
      check_file $_[0] "Included TeX file seems not to be available. Path problem?";

      # Save the argument in the list of files.
      $FILES="$FILES $_[0]";

      # Get the list of files included by the argument.
      extract_files "$_[0]" "include\|input" "";
      $IMPORTS=$FOUND_FILES;

      # Recurse.
      for $file ($IMPORTS ; do);
         getFileList "$file.tex";
      }
   }
}

### Convert all given EPS images to PDF
# parameters ($@): list of EPS images with relative path to working directoy

sub convert_eps2pdf  {
   $IMAGES="$@";
   print "\n";
   print "$MYNAME: Converting EPS images to pdf\n";
   for $image ($IMAGES);
   {
      $IMAGENAME=`basename $image`;
      $IMAGEPATH=`echo "$image" | ${SEDEXE} -n "s/^\(.*\)$IMAGENAME$/\1/p"`;
      $IMAGEBASE=`basename $IMAGENAME .eps`;
      $IMAGEBASE=`basename $IMAGEBASE .ps`;

      #### check if image file really exists
      check_file ${IMAGEPATH}${IMAGENAME} "Could not convert included image.";

      if ( "${IMAGEPATH}${IMAGEBASE}.pdf" -ot "${IMAGEPATH}${IMAGENAME}" ) {
         print "Converting image ${IMAGENAME} ...\n";
         epstopdf -$outfile=${IMAGEPATH}${IMAGEBASE}.pdf ${IMAGEPATH}${IMAGENAME}
         $TMPFILES="$TMPFILES ${IMAGEPATH}${IMAGEBASE}.pdf";
      } else {
         print "${IMAGEBASE}.pdf newer than ${IMAGENAME}, conversion skipped...\n";
      }
   }
}

### Convert all given PSTEX_T files to PDF_T
# parameters ($@): list of PSTEX_T files with relative path to working directoy

sub convert_pstex2pdf  {
   $PSTEXS="$@";
   print "\n";
   print "$MYNAME: Converting PSTEX_T images to PDF\n";
   for $pstexfile ($PSTEXS);
   {
      $PSTEXNAME=`basename $pstexfile`;
      $PSTEXPATH=`echo "$pstexfile" | ${SEDEXE} -n "s/^\(.*\)$PSTEXNAME$/\1/p\"`;
      $PSTEXBASE=`basename $PSTEXNAME .pstex_t`;

      #### check if image file really exists
      check_file ${PSTEXPATH}${PSTEXNAME} "Could not convert included image.";

      # descend into file
      print "Converting file ${PSTEXNAME} ...\n";

      # create .pdf_t file
      $SEDEXE -e "s/\(^[^%]*[\]includegraphics\(\[[^{]*\]\)\?{.*\.\)pstex\(.*$\)/\2pdf\3/g" ${PSTEXPATH}${PSTEXNAME} > "${PSTEXPATH}${PSTEXBASE}.pdf_t";

      # find included EPS image
      $EPSIMAGE=`${SEDEXE} -n "s/^[^%]*[\]includegraphics\(\[[^{]*\]\)\?{\([^}]\+\)}.*$/\2/pg" ${PSTEXPATH}${PSTEXNAME}`;
      $EPSBASE=`basename $EPSIMAGE .pstex`;

      # convert image to pdf
      epstopdf -$outfile=${PSTEXPATH}${EPSBASE}.pdf ${PSTEXPATH}${EPSIMAGE}
      $PDFIMAGES="$PDFIMAGES ${PSTEXPATH}${PSTEXBASE}.pdf";

      $TMPFILES="$TMPFILES ${PSTEXPATH}${PSTEXBASE}.pdf_t ${PSTEXPATH}${PSTEXBASE}.pdf";
   }
}

### generate hyperref parameters from given settings
# HYPERREF_PARAMS: result

sub generate_parameters  {
   local $PARAMS=pdftex;
   if ( $PAPERSIZE ne $NIL ) { $PARAMS="$PARAMS,$PAPERSIZE"; }
   if ( $LINKTOCPAGE eq $YES ) { $PARAMS="$PARAMS,linktocpage"; }
   if ( $TITLE ne $NIL ) { $PARAMS="$PARAMS,pdftitle={$TITLE}"; }
   if ( $AUTHOR ne $NIL ) { $PARAMS="$PARAMS,pdfauthor={$AUTHOR}"; }
   if ( $COLORLINKS eq $YES ) {
      $PARAMS="$PARAMS,colorlinks=true";
      if ( $LINKCOLOR ne $NIL ) { $PARAMS="$PARAMS,linkcolor={$LINKCOLOR}"; }
      if ( $PAGECOLOR ne $NIL ) { $PARAMS="$PARAMS,pagecolor={$PAGECOLOR}"; }
      if ( $URLCOLOR ne $NIL ) { $PARAMS="$PARAMS,urlcolor={$URLCOLOR}"; }
      if ( $CITECOLOR ne $NIL ) { $PARAMS="$PARAMS,citecolor={$CITECOLOR}"; }
   } else {
      $PARAMS="$PARAMS,colorlinks=false";
   }
   if ( $ADDITIONAL_PARAMETERS ) { $PARAMS="$PARAMS,$ADDITIONAL_PARAMETERS"; }
   $HYPERREF_PARAMS=$PARAMS;
}

### Converted included images to pdf and change the corresponding
### reference in the tmp-tex files
# parameter ($1): tex source file
# parameter ($2): tex target file

sub prepare_document  {

   ### set required variables
   local $TEXSOURCE="$_[0]";
   local $TARGETFILE="$_[1]";

   print "\n";
   print "Preparing document: $TEXSOURCE.\n";

   ##### Get EPS images from the source file
   print "\n";
   print "Scanning for EPS images (.eps/.ps):\n";
   extract_files $TEXSOURCE includegraphics "\.e\?ps";
   $EPSIMAGES=$FOUND_FILES;
   if ( $EPSIMAGES ) {
      print "$EPSIMAGES\n";
   } else {
      print "None.\n";
   }

   ##### Get PSTEX_T files from the source file
   print "\n";
   print "Scanning for PSTEX_T files (.pstex_t):\n";
   extract_files $TEXSOURCE input "\.pstex_t";
   $PSTEXS=$FOUND_FILES;
   if ( $PSTEXS ) {
      print "$PSTEXS\n";
   } else {
      print "None.\n";
   }

   ### Save the filename so we can delete it later.
   $TMPFILES="$TMPFILES $TARGETFILE";

   ### if thumbnails should be generated thumbdf package must be used
   if ( $THUMBNAILS eq $YES ) {
      $THUMBPDF_INSERT='\\usepackage{thumbpdf}';
   } else {
      $THUMBPDF_INSERT="% no thumbpdf support";
   }

   ### Insert pdf conversation tags in tex file and write it to TARGETFILE
   print "\n";
   print "$MYNAME: Generating temporary LaTeX document\n";

   ${SEDEXE} -e "s/\([\]includegraphics\)\(\[[^]]*\]\)\?\({[^}]\+\.\)\(e\)*ps}/\1\2\3pdf}/g" \;
   -e "s/\([\]input{[^}]\+\.\)pstex_t}/\1pdf_t}/g" \;
   -e "s/\([\]include{[^}]\+\)}/\1${TMPBASESUFFIX}}/g" \;
   -e "1,/^[\]begin{document}$/s/^[\]batchmode$//" \;
   -e "$INSERTCOMMAND"' \;
   \\usepackage{pslatex}' \;
   -e "$INSERTCOMMAND"' \;
   '"$THUMBPDF_INSERT" \;
   -e "$INSERTCOMMAND"' \;
   \\makeatletter' \;
   -e "$INSERTCOMMAND"' \;
   \\usepackage['"$HYPERREF_PARAMS]{hyperref}"  \;
   -e "$INSERTCOMMAND"' \;
   \\makeatother' \;
   $_[0] > $TARGETFILE;

   ### Convert all EPS images to pdf
   if ( $EPSIMAGES ne "" ) { convert_eps2pdf $EPSIMAGES; }

   ### Convert all PSTEX_T files to PDF_T
   if ( $PSTEXS ne "" ) { convert_pstex2pdf $PSTEXS; }

   print "\n";
   print "Finished: ${TEXSOURCE}.\n";
}

### run pdflatex
# parameter $1: LaTeX file without extension
# parameter $2: log-file where the full out put is stored
# return value: 0 - no errors (no rerun); 1 - errors (rerun required)

sub run_pdflatex  {
   local $TEXFILE=$_[0];
   local $errors=0;
   local $PDFLOGFILE=$_[1];
   local $exit_status=0;
   print "Pdflatex is running. Please wait.\n";
   print "\n";
   pdflatex --interaction nonstopmode ${PDFTEXOPTS} ${TEXFILE} > $PDFLOGFILE;
   $exit_status=$?;
   print "Pdflatex finished. Errors:\n";
   $errors=`grep "! Emergency stop\|Error:\|LaTeX Warning:" $PDFLOGFILE | wc -l`;
   if ( $errors != 0 or $exit_status -ne 0 ) {
      if ( "`grep '! Emergency stop' $PDFLOGFILE`" ) {
         cat $PDFLOGFILE;
	 print "\n";
	 &abort "Fatal error occured. I am lost.";
      }
      if ( $errors != 0 ) {
         grep "Error:\|LaTeX Warning:" $PDFLOGFILE;
      } else {
         tail $PDFLOGFILE;
      }
      print "\n";
      print "$MYNAME: See $PDFLOGFILE for details.\n";
      return 1;
   } else {
      print "None detected (log file: $PDFLOGFILE).\n";
      return 0;
   }
}

#### run bibtex if BIBTEX=$YES or a bibliography tag is found
# included tex files are not parsed for a bibliography
# parmeter $1: filename of the aux file without .aux suffix

sub handle_bibtex  {
   $AUXFILE=$_[0];
   print "\n";
   if ( $BIBTEX eq $YES ) {
      $BIBLIO=1;
      print "$MYNAME: BibTeX paramter set to '$YES'; running BibTeX.\n";
   } else {
      print "$MYNAME: Checking for BibTeX bibliography in document.\n";
      $BIBLIO=`grep "^[^%]*[\]bibliography{" ${AUXFILE}.tex | wc -l`;
      if ( $BIBLIO != 0 ) {
         print "Bibliography detected; running BibTeX.\n";
      } else {
         print "No bibliography detected.\n";
      }
   }
   if ( $BIBLIO != 0 ) {
      if ! bibtex ${AUXFILE} > ${BIBTEXLOG}
         $BIBTEXERR=1;
      } else {
         $BIBTEXERR=`grep "error message" ${BIBTEXLOG} | wc -l`;
      }
      if ( $BIBTEXERR != 0 ) {
         print "\n";
         print "****************** BibTeX errors reported *******************\n";
         cat ${BIBTEXLOG}
         print "*************************************************************\n";
         print "\n";
         print "$MYNAME: You can switch off BibTeX support by setting $BIBTEX=$NO in the parameter section of $MYNAME.\n";
      } else {
         print "BibTeX finished without errors.\n";
      }
   }
}

#### run thumbpdf command to make thumbnails
# more informations: /usr/share/texmf/doc/pdftex/thumbpdf/readme.txt
# parameter $1: LaTeX file without extension

sub run_thumbpdf  {
   local $TEXFILE=$_[0];
   local $exit_status=0;
   print "\n";
   print "$MYNAME: Creating thumbnails with 'thumbpdf'\n";
   print "\n";
   thumbpdf ${TEXFILE}
   $exit_status=$?;
   if ( $exit_status != 0 ) {
      print "\n";
      print "$MYNAME: thumbpdf exit with status $exit_status.\n";
      print "I will continue, but maybe there will not be thumbs in the PDF doc.\n";
   }

   if ( -f thumbpdf.log ) {
   then ;
      mv thumbpdf.log $THUMBPDFLOG;
      print "\n";
      print "$MYNAME: See $THUMBPDFLOG for details.\n";
   }

   print "\n";
   print "Cleaning up (thumbpdf) ...\n";
   print "\n";
   system "rm -f thumb???.png";
   system "rm -f thumbpdf.pdf";
   if ( -f "thumbdta.tex" ) { $TMPFILES="$TMPFILES thumbdta.tex"; }
}

################## Lift off !!!! (main part) ##################
$MYNAME=`basename $0`;
$TMPBASE=;
$TMPFILES=;
$TITLE=;
$AUTHOR=;

print "\n";
print "$MYNAME: Script starts (Release $MYRELEASE)\n";

##### Check arguments
print "\n";
print "$MYNAME: Processing given parameters and arguments.\n";
check_arguments $@;

##### command line options and private configuration files handling
$CONFIGURE_REQ=$NO;

### scan parameters (1st level)
$OPTIND=1;
while getopts hvorb:c:p:i:t:a:l:n:d: OPTION;
{
   case "$OPTION" in;
      h) help; exit 0 ;;;
      v) print_version; exit 0 ;;;
      o) $PRINT_ONLY=$YES ;;;
      r) $CONFIGURE_REQ=$YES;;;
	 b|c|p|i|t|a|l|n|d) ;;;
      *) usage; exit 1 ;;;
   esac;
}

### set parameters from rc file
if ( -f $RC_FILENAME ) {
  read_configuration;
  #### compatibilty with old RC files where SEDEXE could be ""
  if ( $SEDEXE eq "" ) { $SEDEXE=sed; }
} else {
  if ( $PRINT_ONLY ne $YES and $CONFIGURE_REQ ne $YES ) {
     &abort "Script is not configured. Please run $MYNAME -r.";
  }
}

### configure parameters
if ( $CONFIGURE_REQ eq $YES ) {
  configure;
  write_configuration;
  print_configuration;
  exit 0;
}

### scan parameters (2nd level)
$OPTIND=1;
while getopts b:p:i:t:a:l:c:n:d: OPTION;
{
  case "$OPTION" in;
    i) setYNValue MAKEINDEX $OPTARG i ;;;
    t) $TITLE=$OPTARG ;;;
    a) $AUTHOR=$OPTARG ;;;
    b) setValue BIBTEX $OPTARG b "$POSSIBLE_BIBTEX" ;;;
    p) setValue PAPERSIZE $OPTARG p "$POSSIBLE_PAPER" ;;;
    c) setYNValue COMMANDCHECK $OPTARG r ;;;
    n) setYNValue THUMBNAILS $OPTARG n ;;;
    l) setYNValue CLEANLOGS $OPTARG l ;;;
    d) if check_dir $OPTARG;
	     $PDFCUSTOMDIR=$OPTARG;
	     $PDFOUT=$POSSIBLE_PDFOUT[2];
	  } else {
	     &abort "Please, choose a VALID path.";
	  fi ;;;
  esac;
}

### print configuration parameters

if ( $PRINT_ONLY eq $YES ) {
   print_configuration;
   exit 0;
}

#### remove all command line options, leave the document argument as $1
shift $(($OPTIND - 1));

##### Preparing the LOGDIR
if ! mkdir -p ${LOGDIR}
   print "\n";
   print "$MYNAME: Could not create log directory ($LOGDIR).\n";
   print "Aborting ...\n";
   exit 1;
}

if ( $LOGFILES and "`ls ${LOGDIR}`" and $CLEANLOGS eq $YES ) {
   print "\n";
   print "Removing old log files ($LOGDIR).\n";
   system "rm ${LOGDIR}pdflatex-*.log ${LOGDIR}bibtex-*.log ${LOGDIR}thumbpdf-*.log";
} else {
   print "\n";
   print "All log files will be stored in ($LOGDIR).\n";
}

### make sure that TMPBASESUFFIX is not empty
if ( $TMPBASESUFFIX eq "" ) {
   print "\n";
   print "$MYNAME: CAUTION: Parameter TMPBASESUFFIX is not set.\n";
   &abort "Using these settings would destroy the original files!";
}

##### check for required commands
if ( $SEDEXE ne "`basename $SEDEXE`" and ! -x $SEDEXE ) {
   print "\n";
   print "$MYNAME: Specified sed executable not found (${SEDEXE})\n";
   print "Using sed executable in your path.\n";
   print "Maybe it does not work. GNU sed v3.02 or higher is recommended.\n";
   $SEDEXE=sed;
}

if ( $COMMANDCHECK ne $NO ) {
   check_commands;
}

##### Check arguments
print "\n";
print "$MYNAME: Analysing your document argument.\n";

##### Getting document name and path
$DOCUMENT="$_[0]";
$DOCNAME=`basename $DOCUMENT`;
$DOCPATH=`echo "$DOCUMENT" | ${SEDEXE} -e "s/^\(.*\)$DOCNAME/\1/"`;

###### change working directory to document directory
if ( $DOCPATH ne "" ) {
   cd $DOCPATH;
}

###### make DOCPATH an absolute path
$DOCPATH=`pwd`/;

###### Cut off suffix and do lyx or tex specific stuff
$DOCBASE=`basename $DOCNAME .lyx`;
if ( $DOCBASE ne $DOCNAME ) {
   ### DOCNAME has an extention .lyx => Lyx document
   # generate Latex document if required
   generate_tex_file ${DOCBASE}.lyx ${DOCBASE}.tex;
} else {
   ### given file is a LaTeX file
   # cut off .tex extension if there is one
   $DOCBASE=`basename $DOCNAME .tex`;

   ###### check access to given LaTeX document
   check_file ${DOCBASE}.tex "Cannot read the specified LaTeX document!";
}

$PASSEDTEXDOC=${DOCPATH}${DOCBASE}.tex;
$TMPBASE=${DOCBASE}${TMPBASESUFFIX}

### set some more variables

# setting the log files for the output of pdflatex, bibtex and thumbpdf
$PDFLOGBASE=${LOGDIR}pdflatex-$$-;
$BIBTEXLOG=${LOGDIR}bibtex-$$.log;
$THUMBPDFLOG=${LOGDIR}thumbpdf-$$.log;

##### Get title and author from main LaTeX document
print "\n";
print "$MYNAME: Parsing LaTeX file\n";
if ( $TITLE eq "" ) {
   $TITLE=`${SEDEXE} -n "s/^.*[\]title{\([^{}]*\)}.*$/\1/1p" $PASSEDTEXDOC`;
   if ( $TITLE eq "" ) {
      print "\n";
      print "$MYNAME: WARNING: Could not identify document's title correctly.\n";
      print "Maybe you have used a LaTeX Tag inside the title which confuses me.\n";
      print "You can either set a title on the command line using option -t or\n";
      print "change the title of the LaTeX file in order to avoid the problem.\n";
      if ( $DEFAULT_TITLE ne "" ) {
         print "Using default title: $DEFAULT_TITLE\n";
	 $TITLE=$DEFAULT_TITLE;
      } else {
         print "Title field will be empty.\n";
      }
   } else {
     print "Document's title: $TITLE\n";
   }
}

if ( $AUTHOR eq "" ) {
   $AUTHOR=`${SEDEXE} -n "s/^.*[\]author{\([^{}]*\)}.*$/\1/1p" $PASSEDTEXDOC`;
   if ( $AUTHOR eq "" ) {
      print "\n";
      print "$MYNAME: WARNING: Could not identify document's author correctly.\n";
      print "Maybe you have used a LaTeX Tag inside the author field which confuses me.\n";
      print "You can either set an author on the command line using option -a or\n";
      print "change the author of the LaTeX file in order to avoid the problem.\n";
      if ( $DEFAULT_AUTHOR ne "" ) {
         print "Using default title: $DEFAULT_AUTHOR\n";
	 $AUTHOR=$DEFAULT_AUTHOR;
      } else {
         print "Author field will be empty.\n";
      }
   } else {
     print "Document's author: $AUTHOR\n";
   }
}

print "\n";

# translate hyperref settings to the actual package parameters 
generate_parameters;

###### change working directory to INPUTPATH if set
# When the files' path (images, included documents, etc.) in your document is
# relative to another directory than the PASSED document's directory.
# This is useful when the calling application (e.g. LyX) generates a temporary
# TeX file and calls the tex2pdf with it instead of the original file.
$INPUTPATH=`$SEDEXE -n "s|^[\]def[\]input@path{\+\([^{}]*\)}\+|\1|1p" $PASSEDTEXDOC`;

## check if INPUTPATH is ok
if ( $INPUTPATH ne "" ) {
   print "$MYNAME: Found an input path in the latex document: $INPUTPATH\n";
   if ( -d $INPUTPATH and -r $INPUTPATH ) {
      print "Change working directory to input path.\n";
      cd $INPUTPATH;
   } else {
       &abort "The retrieved input@path seems not to be valid.";
   }
} else {
   print "$MYNAME: No input path in the latex document found.\n";
   print "Resources are expected to be relative to document's location: $DOCPATH\n";
}

# set the directory where the final pdf will be stored
$PDFOUTDIR=;
case $PDFOUT in;
   $POSSIBLE_PDFOUT[2]) $PDFOUTDIR=$PDFCUSTOMDIR ;;;
   $POSSIBLE_PDFOUT[1]) $PDFOUTDIR=$INPUTPATH ;;;
   $POSSIBLE_PDFOUT[0]) $PDFOUTDIR=$DOCPATH ;;;
esac;

if ( $PDFOUTDIR eq "" ) { $PDFOUTDIR=$DOCPATH; }

##### Get the list of imported files from the tex file
$FILES=;
getFileList $PASSEDTEXDOC;

# remove main file from list (needs special handling)
$FILES=`echo "$FILES" | ${SEDEXE} -e "s|^ *$PASSEDTEXDOC||"`;

if ( $FILES ne "" ) {
   print "\n";
   print "Found the following included TeX files:\n";
   for $file ($FILES ; do);
      print ">>>>> $file\n";
   }
} else {
   print "\n";
   print "Found no included TeX files.\n";
}

##### Generate adjusted tex files and convert all their images
# main file
prepare_document $PASSEDTEXDOC ${TMPBASE}.tex;

# included files
if ( $FILES ne "" ) {
   for $file ($FILES ; do);
      $TMP_FILE=`echo $file | ${SEDEXE} -e "s/\.tex$//"`;
      prepare_document $file ${TMP_FILE}${TMPBASESUFFIX}.tex;
   }
}

##### Generate the final PDF document
### run pdflatex until no more errors are reported (max MAXRUNNO)
$runno=1;
$rerun=1;
while ( $rerun != 0 and $runno <= $MAXRUNNO )
{
   print "\n";
   print "************ Pdflatex run no. $runno *************\n";
   if run_pdflatex ${TMPBASE} "${PDFLOGBASE}${runno}.log" && ( $MINRUNNO <= $runno ) {
      # no errors detected and MINRUNNO is processed
      $rerun=0;
   } else {
      # errors or MINRUNNO has not been reached
      $rerun=1;
   }

   ### Execute BibTeX after first run if set (and required)
   if ( $runno == 1 and $BIBTEX ne $NO ) {
      handle_bibtex ${TMPBASE}
   }

   $runno=$((runno+1));
}

$rerun=0;

### if the THUMBNAILS option is switched on then make thumbnails
if ( $THUMBNAILS eq $YES ) {
   run_thumbpdf ${TMPBASE}
   $rerun=1;
}

### generate index if required
if ( -f ${TMPBASE}.idx  and $MAKEINDEX ne $NO ) {
   print "\n";
   print "$MYNAME: Document seems to have an index. Generating ...\n";
   print "\n";
   makeindex ${TMPBASE}.idx;
   $rerun=1;
}

### One final pdflatex run if requested
if ( $rerun != 0 ) {
   print "\n";
   print "************ One final pdflatex run no. $runno *************\n";
   run_pdflatex ${TMPBASE} "${PDFLOGBASE}${runno}.log";
}

##### Clean up
if ( -f ${TMPBASE}.pdf ) {
   mv ${TMPBASE}.pdf ${PDFOUTDIR}${DOCBASE}.pdf;
} else {
   print "\n";
   print "$MYNAME: The PDF file ${TMPBASE}.pdf was not generated.\n";
   clean_up;
   print "Aborting ...\n";
   exit 1;
}

print "\n";
clean_up;

print "\n";
print "The new pdf file is: ${PDFOUTDIR}${DOCBASE}.pdf\n";
print "\n";

