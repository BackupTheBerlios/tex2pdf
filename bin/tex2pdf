#!/usr/bin/perl -w

#      tex2pdf - script for translating latex docs to pdf
#
#      Copyright (C) 2000,2001 by Steffen Evers
#
#      This program is free software; you can redistribute it and/or modify
#      it under the terms of the GNU General Public License version 2 as 
#      published by the Free Software Foundation.
#
#      This program is distributed in the hope that it will be useful,
#      but WITHOUT ANY WARRANTY; without even the implied warranty of
#      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#      GNU General Public License for more details.
#
#      You should have received a copy of the GNU General Public License
#      along with this program; if not, write to the Free Software
#      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#      The GNU General Public License is also available online:
#      http://www.gnu.org/licenses/gpl.html
#
# Thanks a lot to all the people that have already contributed to this project!
#
# The changelog including the credits has become too long. So, I have removed it
# from the script, but it is still available online (see below). 
#
# Special thanks to the following people for their contribution
# (see the changelog for details):
# Matej Cepl, Herbert Voss, Nicolas Marsgui, Bruce Foster, Mark van Rossum,
# Matt Bandy, Garrick Chien Welsh, Stacy J. Prowell, Pavel Sedivy,
# Holger Daszler, Olaf Gabler, Ahmet Sekercioglui, Richard, Steffen Macke
#
# Project Homepage: http://tex2pdf.berlios.de
# Developer Homepage: http://developer.berlios.de/projects/tex2pdf
# Mailing lists: http://developer.berlios.de/mail/?group_id=57
# Changelog: http://tex2pdf.berlios.de/changelog.html
#
# Anyone is invited to help to improve tex2pdf. Therefore any kind of feedback
# is welcome. Maybe you even would like to hack the code and send us your
# changes. This would help a lot and is highly appreciated. Think about it :-)
# Subscribing to the developer mailing list might be a first step (see above).
#
# Send feedback to: tex2pdf-devel@lists.berlios.de
#

######## Imports

use File::Basename;
use Getopt::Std;

####### Release version

$MYRELEASE="2.2.8pl";
$MYNAME="tex2pdf.pl";

##### You will need pdftex and epstopdf for the generation!
##### See pdftex homepage for details: http://tug.org/applications/pdftex/
##### Have fun!!!

##### Default parameters
## Change the parameters below if you want to change the default settings for
## all users.  If you only want to change your private parameters change them
## in the RC_FILENAME

### text token for no value
$NIL="NOVALUE";

### token for boolean 'false', 'no' 
$NO="no";
$FALSE=0;

### token for boolean 'true', 'yes' 
$YES="yes";
$TRUE=1;

### pdftex package options:
### see hyperref manual for more:/usr/share/texmf/doc/latex/hyperref/manual.pdf

# possible paper sizes
# this list MUST have the syntax "PAPER1 PAPER2 ..."
$POSSIBLE_PAPER = [ qw< a4paper letterpaper legalpaper executivepaper >, $NIL ];

# papersize of the resulting pdf document
$PAPERSIZE="a4paper";

# use color for links in the resulting document
# options: 'yes' or 'no'
$COLORLINKS=$YES;

# possible link colors
# this list MUST have the syntax "COLOR1 COLOR2 ..."
$LINK_COLORS= [ qw< yellow red green cyan blue magenta black >, $NIL ];

# color to use for page links in resulting document
# some possible values: see above
# set to $NIL for default value
$PAGECOLOR="magenta";

# color to use for regular internal links in resulting document
# some possible values: see above
# set to $NIL for default value
$LINKCOLOR="green";

# color to use for URLS in resulting document
# some possible values: see above
# set to $NIL for default value
$URLCOLOR="blue";

# color to use for citations in resulting document
# some possible values: see above
# set to $NIL for default value
$CITECOLOR="red";

# Default title for document info in the resulting PDF 
# leave blank for default value
$DEFAULT_TITLE=$NIL;

# Default author for document info in the resulting PDF 
# leave blank for default value
$DEFAULT_AUTHOR=$NIL;

# additional parameters for hyperref package
# format: PARAMETERNAME={VALUE},PARAMETERNAME={VALUE},...
# leave blank for no additional values
$ADDITIONAL_PARAMETERS="";

# link tabel of contents to pages instead of sections
# sets linktocpage
$LINKTOCPAGE=$YES;

### other parameters

# place where generated pdf file is stored:
# source_dir - same directory as the LaTeX file
# input_dir  - same directory as the input files of the LaTeX file
# custom     - specified directory PDFCUSTOMDIR
$POSSIBLE_PDFOUT= [ qw< source_dir input_dir custom > ];
$PDFOUT = @$POSSIBLE_PDFOUT[0];

# custom directory where the generated pdf file is stored
$PDFCUSTOMDIR=$ENV{'HOME'};

# usage of bibtex
# possible values: 'yes' (always run bibtex), 'no' (never run bibtex),
# 'test' (scan tex file for a bibtex entry and run it if required)
$POSSIBLE_BIBTEX= [ $YES, $NO, "test" ];
$BIBTEX="test";

# maximal number of runs for pdflatex
$MAXRUNNO=6;

# minimal number of runs for pdflatex
# This option can be used to force pdflatex to run at least MINRUNNO times even
# when tex2pdf cannot detect any more warnings or errors.
# This might help if there is no table of contents or other things are missing.
# possible values: 1 ... MAXRUNNO
$MINRUNNO=2;

# directory for log files
$LOGDIR="/tmp/tex2pdf-$ENV{'USER'}/";

# clean log files before execution
# You might get problems with this when you run tex2pdf on several documents
# at the same time. So, if you want to be on the safe side set "no" and clean
# the log directory manually.
# possible values: 'yes', 'no'
$CLEANLOGS=$NO;

# Use which command to check for required executables
# possible values: 'yes', 'no'
$COMMANDCHECK=$YES;

# use thumbpdf to include thumbnails of all PDF document pages
# requires ghostscript version 5.50 or higher to generate the thumbnails (PNG)
# see more informations: /usr/share/texmf/doc/pdftex/thumbpdf/readme.txt
# possible values: "yes" for thumbnails, "no" - without thumbnails
$THUMBNAILS=$NO;

# execution of the makeindex command for index handling
# this should fix the problem with a missing document index
# possible values: "yes" - check for index file and if found call makeindex
#                  "no"  - never execute it
$MAKEINDEX=$YES;

##### expert parameters
## the following parameters should NOT be modified by regular users!
## study the script carefully before you change them !!!

# the sed executable this script should use for the configuration part
# simply 'sed' means script should use the sed in your path
$SEDCMD="sed";

# the sed executable this script should use for the parsing
# simply 'sed' means script should use the sed in your path
$SEDEXE="sed";

# additional options for pdflatex
$PDFTEXOPTS="";

# suffix for tmp files that will be put in between the basename and suffix of
# the original file
# CAUTION: If you leave this blank you will overwrite the original files!
$TMPBASESUFFIX="-pdf";

# remove all tmp files on abort
$CLEAN_ON_ABORT=$NO;

# sed command which is used to insert additional TeX commands in the LaTeX
# preamble
# try the following commands if you have strange errors or junk on the
# first PDF document page
# INSERT_REGEXP="/^\\begin\{document\}$/i"
# INSERT_REGEXP="/^[\]makeatletter$/i"
$INSERT_REGEXP='^\\documentclass(\[[^]]*\])?\{.*\}';

### file to store private parameters
# If you only want to change your private parameters change them there
# default: $HOME/.tex2pdfrc
$RC_FILENAME="$ENV{'HOME'}/.tex2pdfrc";

# variables for the rc file
# list of all variables that should be stored/read in/from the rc file
# this list MUST have the syntax "VARIABLE1 VARIABLE2 ..."
$RC_VARIABLES= [ qw< PAPERSIZE COLORLINKS PAGECOLOR LINKCOLOR URLCOLOR
   CITECOLOR DEFAULT_TITLE DEFAULT_AUTHOR LINKTOCPAGE ADDITIONAL_PARAMETERS
   PDFOUT PDFCUSTOMDIR SEDEXE BIBTEX MAXRUNNO MINRUNNO LOGDIR CLEANLOGS
   PDFTEXOPTS COMMANDCHECK THUMBNAILS TMPBASESUFFIX MAKEINDEX INSERT_REGEXP
   > ];

##### Functions ###########################################

### Index of the first occurence of a string in an array
# parameter 1: list
# parameter 2: text
# return value: index or -1 if not element of the array 

sub array_index {
   my (@list, $text) = @_;

   foreach (0..$#list)) {
      if ( @list[$_] eq $text ) { return $_; }
   }
   
   return -1;
}

### Removing all temporary files

sub clean_up {
   print "$MYNAME: Removing temporary files ...\n";
   if ( @TMPFILES > 0 ) { unlink @TMPFILES; }
   if ( $TMPBASE ne "" ) { unlink glob "$TMPBASE.*"; }
}

###  exit with an error message

sub abort {
   print "$MYNAME: @_\n";
   if ( $CLEAN_ON_ABORT eq $YES ) { &clean_up; }
   print "Aborting ...\n";
   exit 1;
}

#### General functions (not script specific)

### interactively answer a question with yes or no
# parameter 1: question
# parameter 2: default value (not set means $NIL)
# parameter 3: yes: allow undefined as third value
#              no : only yes/no allowed (default)
# return value: the given answer

sub question_ynu {
   my $user_input;
   my $question = $_[0];
   my $default = defined($_[1]) ? $_[1] : $NIL;
   my $undef_allowed = defined($_[2]) and $_[2] eq $YES;
   my $response = undef;

   if( $default =~ /^y(es)?/i ) {
      $question .= ' [y]: ';
      $default = $YES;
   } elsif ( $default eq $NIL and $undef_allowed ) {
      $question .= ' [u]: ';
      $default = $NIL;
   } else {
      $question .= ' [n]: ';
      $default = $NO;
   }
   while (! defined($response)) {
      print $question;
      $user_input = <STDIN>;
      chomp($user_input);
      
      if( $user_input =~ /^y(es)?/i ) {
         $response=$YES;
      } elsif ( $user_input =~ /^no?/i ) {
         $response=$NO;
      } elsif ( $user_input =~ /^u(ndef(ined)?)?/i and $undef_allowed ) {
         $response=$NIL;
      } elsif ( $user_input eq "" ) {
         $response=$default;
      } else {
         print "Please respond with y(es)";
         print ", u(ndefined)" if($undef_allowed);
         print " or n(o).\n";
      }
   }
   return $response;
}

### interactively input a positive integer number
# parameter 1: question
# parameter 2: default value
# parameter 3: min value
# parameter 4: max value
# return value: the input number

sub input_number {
   my $question = $_[0];
   my $default = $_[1];
   my $min_limit = $_[2];
   my $max_limit = $_[3];
   my $response= undef;

   while (! defined($response)) {
      print "$question [$default]: ";
      my $user_input = <STDIN>;
      chomp($user_input);
      
      if ($user_input eq "") {
         $response=$default;
      } else {
         $_ = $user_input;
         if (s/^([[:digit:]]+)$/$1/ and $_ >= $min_limit and $_ <= $max_limit ) {
            $response = $_;
	 } else {
            print "Invalid input. Please enter a positve integer from $min_limit to $max_limit.\n";
         }
      }
   }
   return $response;
}

### interactively choose between several given values
# parameter 1: question
# parameter 2: default value
# parameter 3: reference to a list of possible values
# return value: the chosen value

sub choose_value {
   my $question=$_[0];
   my $default=$_[1];
   my @possible_values=@$_[2];
   my $list_index=1;
   my $default_no=1;
   my $chosen_no;

   print "$question\n";
   foreach (@possible_values)
   {
      print "$list_index) $_\n";
      if ( $default eq $_ ) { $default_no=$list_index; }
      $list_index = $list_index + 1;
   }

   $chosen_no=&input_number("Please enter the corresponding number", $default_no, 1, $#possible_values);
   return $possible_values[$chosen_no - 1];
}

### interactively answer a question
# parameter 1: question
# parameter 2: current value
# return value: the new value

sub input_text {
   my $question=$_[0];
   my $default=$_[1];
   my $response= undef;

   print "Suggested value: $default\n";
   if ( &question_ynu("Do you want to keep this value?", $YES) eq $YES ) {
      $response= $default;
   } else {
      print "$question ";
      my $user_input = <STDIN>;
      chomp($user_input);
      
      $response = $user_input;
   }
   return $response;
}

##### Make sure that specified file exists and is readable; abort if missing
# parameter 1: file to check
# parameter 2: remark if check fails on specified file

sub check_file {
   my $file = $_[0];
   my $message = defined($_[1]) ? $_[1] : "Required file cannot be accessed!";

   if ( ! -f $file ) {
      print "\n";
      print "$MYNAME: Sorry. I cannot find '$file'.\n";
      &abort($message);
   } elsif ( ! -r $file ) {
      print "\n";
      print "$MYNAME: Sorry. File '$file' exists, but is not readable.\n";
      &abort($message);
   }
}

##### Make sure that specified directory exists and is writable
# parameter 1: directory to check
# parameter 2: remark if check fails on specified directory
# parameter 3: if yes, creation is allowed
# return value: $TRUE - ok; $FALSE - error

sub check_dir {
   my $directory = $_[0];
   my $message = defined($_[1]) ? $_[1] : "Not a valid path!";
   my $allow_creation = defined($_[2]) ? $_[2] : $NO;

   if ( index($directory, "/") != 0 ) {
      print "\n";
      print "$MYNAME: Sorry. '$directory' is not an absolute path.\n";
      print "$message\n";
      return $FALSE;
   } elsif ( ! -d $directory ) {
      # dir does not exist
      print "\n";
      if ( $allow_creation eq $YES ) {
         # creation allowed
         print "$MYNAME: I cannot find '$directory'. Try to create it.\n";
	 if ( mkdir($directory, 0755) ) {
	    print "Creation of '$directory' was successful.\n";
	    return $TRUE;
	 } else {
	    print "$MYNAME: Creation of '$directory' failed.\n";
	    print "$message\n";
	    return $FALSE;
	 }
      } else {
         # creation not allowed
         print "$MYNAME: Sorry. Directory '$directory' does not exist.\n";
         print "$message\n";
         return $FALSE;
      }
   } elsif ( ! -w $directory ) {
      # dir not writable
      print "\n";
      print "$MYNAME: Sorry. Directory '$directory' exists, but is not writable.\n";
      print "$message\n";
      return $FALSE;
   }
   return $TRUE;
}

### interactively input an directory for data storage (absolute path)
# parameter 1: question
# parameter 2: default dir
# parameter 3: if 'yes' allow creation of directory
# return value: the specified directory

sub input_dir {
   my $question = $_[0];
   my $default_dir = $_[1];
   my $allow_creation = defined($_[2]) ? $_[2] : $NO;
   my $user_input;
   my $response = undef;

   if ( defined($default_dir) and index($default_dir, "/") == 0 
        and ( (! -d $default_dir and $allow_creation eq $YES) 
        or (-d $default_dir and -w $default_dir) ) ) {
      $question .= " [$default_dir]: ";
   } else {
      $default_dir = undef;
      $question .= ": ";
   }

   while (! defined($response)) {
      print "$question";
      $user_input = <STDIN>;
      chomp($user_input);
      
      if( $user_input eq "" and defined($default_dir) ) {
         # user has only pressed <ENTER> and thereby confirmed default value
	 if( ! &check_dir($default_dir,"Default value was not valid. Please, give different directory.", $allow_creation ) ) {
	    # default dir does not exist and cannot be created
	    $default_dir = undef;
	    $question = "$_[0]: ";
	 } else {
	    # valid default dir has already existed or has been created
            $response = $default_dir;
	 }
      } else {
         # user has given a directory
         if( &check_dir($user_input,"This is not a valid directory!", $allow_creation) ) {
	    $response = $user_input;
         }
      }
   }
   return $response;
}

### set a variable by a command line option to 'yes' or' no'; abort on error
# parameter 1: variable
# parameter 2: given value
# parameter 3: option letter

sub setYNValue {
   my $variable = $_[0];
   my $argument = $_[1];
   my $option_letter = $_[2];

   if( $argument =~ /^[yY]([Ee][Ss])?/ ) {
      $$variable = $YES;
   } elsif ( $argument =~ /^[Nn][Oo]?/ ) {
      $$variable = $NO;
   } else {
      print "\n$variable requires '$YES' or '$NO'." ;
      &abort("Illegal argument for option -$option_letter: $argument");
   }
}

### set a variable by a command line option to a possible values; abort on error
# parameter 1: variable
# parameter 2: given value
# parameter 3: option letter
# parameter 4: list of possible values

sub setValue {
   my $variable = $_[0];
   my $argument = $_[1];
   my $option_letter = $_[2];

   shift @_;
   shift @_;
   shift @_;

   my @possible_values = @_;

   if ( index("@possible_values", $argument) < 0 ) {
      print "\n$variable allows: @possible_values.\n";
      &abort("Illegal argument for option -$option_letter: $argument");
      exit 1;
   }
   $$variable = $argument;
}

### Check for required command with 'which'; abort if not found
# parameter $1: command to check
# parameter $2: remark if specified command is not found

sub checkCommand {
   my $command = $_[0];
   my $message = $_[1];

   $_ = `which $command 2>&1`; 
   chomp;
   s|^(.*/)?([^/]+)$|$2|;

   if ( $_ ne $command ) {
      print "\n";
      system "which", $command;
      print "\n";
      print "$MYNAME: Required command '$command' seems not to be in your path.\n";
      if ( defined($message) ) {
         print "$message\n";
      }
      print "Aborting ...\n";
      exit 1;
   }
}

### save configuration in rc file

sub write_configuration {
   my $date;
   open(RCFILE, ">$RC_FILENAME") or
      &abort("Could not open configuration file for writing ($RC_FILENAME)");
   select RCFILE;

   $date = `date`;
   chomp($date);
   
   print "# Configuration file for $MYNAME V$MYRELEASE\n";
   print "# Generated $date by $ENV{'USER'} on $ENV{'HOSTNAME'}\n";
   
   foreach my $variable (@$RC_VARIABLES) {
      print "$variable".'='."$$variable\n";
   }
   
   print "# EOF\n";
   select STDOUT;
   close RCFILE;
}

### print the configuration parameters
sub print_configuration {
   print "Configuration for $MYNAME V$MYRELEASE\n";
   
   foreach my $variable (@$RC_VARIABLES) {
      print "$variable".'='."$$variable\n";
   }
   
   print "\n";
}

### load parameters from rc file

sub read_configuration {
   my $line;

   &check_file($RC_FILENAME, "Could not access configuration file");
   open(RCFILE, "<$RC_FILENAME") or
      &abort("Could not open configuration file for reading ($RC_FILENAME)");

   while (defined($line = <RCFILE>)) {
      foreach my $parameter (@$RC_VARIABLES) {
         $_ = $line;
         chomp;
         if( s/^$parameter=([[:print:]]*)$/$1/ ) {
            $$parameter = $_; 
         }
      }
   }
   close RCFILE;
}

###################### Specific functions (for use with this script only)

### print usage of command

sub usage {
   print "\n";
   print "Usage: $MYNAME [OPTIONS] DOCUMENT.lyx\n";
   print "       $MYNAME [OPTIONS] DOCUMENT.tex\n";
   print "       $MYNAME [-h|-v|-o|-r]\n";
   print "\n";
}

### print command help

sub help {
   print "\n";
   print "$MYNAME Version $MYRELEASE\n";
   @usage;
   print " -h : print this message\n";
   print " -v : print version information\n";
   print " -o : print configuration parameters\n";
   print " -r : run configure parameters\n";
   print "\n";
   print " -i BOOL   : makeindex\n";
   print " -l BOOL   : clean log files\n";
   print " -c BOOL   : check for required commands\n";
   print " -n BOOL   : generate thumbnails for PDF document\n";
   print " -t TITLE  : specify title for PDF document info\n";
   print " -a AUTHOR : specify author for PDF document info\n";
   print " -p SELECT : select papersize: @$POSSIBLE_PAPER\n";
   print " -b SELECT : select bibtex handling: @$POSSIBLE_BIBTEX\n";
   print " -d PATH   : custom directory where the final PDF is stored\n";
   print "\n";
}

### print script version

sub print_version   {
   print "\n";
   print "$MYNAME Version $MYRELEASE\n";
   print "\n";
}


### configure tex2pdf parameters interactively

sub configure  {
   print "\nConfiguration for tex2pdf.\n";
   print "The following answers are considered as defaults in later executions\n";
   print "of $MYNAME. You can change these values by using option -r.\n";
   print "The command-line options override these settings.\n";
   print "Many parameters can be set to '$NIL'. This means that NO value at\n";
   print "all (not even an empty value) is passed over to the called\n";
   print "application (e.g. latex package hyperref).\n";

   print "\n----------------\n";
   print "$MYNAME can set the papersize of the resulting PDF document.\n";
   $PAPERSIZE=&choose_value("What papersize should be used?",$PAPERSIZE,$POSSIBLE_PAPER);

   print "\n----------------\n";
   print "The table of contents of the resulting PDF document is normally linked\n";
   print "to the corresponding section. However, you can also link it to the\n";
   print "corresponding page instead.\n";
   $LINKTOCPAGE=&question_ynu("Should TOC be linked to pages?",$LINKTOCPAGE);

   print "\n----------------\n";
   print "$MYNAME can use different colors for links inside the PDF document.\n";
   $COLORLINKS=&question_ynu("Should colors be used for links?",$COLORLINKS);

   if ( $COLORLINKS eq $YES ) {
        print "\n----------------\n";
        print "It is possible to specify the color for page links.\n";
        $PAGECOLOR=&choose_value("What color should be used for page links?",$PAGECOLOR,@LINK_COLORS);

        print "\n----------------\n";
        print "It is possible to specify the color for normal internal links.\n";
        $LINKCOLOR=&choose_value("What color should be used for normal links?",$LINKCOLOR,@LINK_COLORS);

        print "\n----------------\n";
        print "It is possible to specify the URL color.\n";
        $URLCOLOR=&choose_value("What color should be used for URLs?",$URLCOLOR,@LINK_COLORS);

        print "\n----------------\n";
        print "It is possible to specify the citation color.\n";
        $CITECOLOR=&choose_value("What color should be used for citation?",$CITECOLOR,@LINK_COLORS);
   }

   print "\n----------------\n";
   print "A PDF document contains meta data about itself: the document info.\n";
   print "Two of the info fields (title, author) can be set here as default\n";
   print "value which will be used in the case that $MYNAME cannot determine\n";
   print "proper settings from the LaTeX document.\n\n";

   print "The default title for the document info of all generated documents.\n";
   print "$NIL will be recognized.\n\n";
   $DEFAULT_TITLE=&input_text("Default document title?",$DEFAULT_TITLE);

   print "\n----------------\n";
   print "The default author for the document info of all generated documents.\n";
   print "$NIL will be recognized.\n\n";
   $DEFAULT_AUTHOR=&input_text("Default document author?",$DEFAULT_AUTHOR);

   print "\n----------------\n";
   print "If you like you can make me pass additional parameters to hyperref.\n";
   print "See the hyperref manual for possible values and details.\n";
   print "These parameters should normally have the format:\n";
   print "PARAMETERNAME={VALUE},PARAMETERNAME={VALUE},...\n";
   print "Leave blank for no additional values.\n\n";
   $ADDITIONAL_PARAMETERS=&input_text("Additional parameters ?",$ADDITIONAL_PARAMETERS);

   print "\n----------------\n";
   print "You can now specify in which directory the resulting document should\n";
   print "be written by default:\n";
   print "- '@$POSSIBLE_PDFOUT[0]' means the same directory as the LaTeX file.\n";
   print "- '@$POSSIBLE_PDFOUT[1]' means the same directory as the input files of your\n";
   print "  LaTeX file (e.g. images, included documents, etc.).\n";
   print "  This path should be specified in the source LaTeX document otherwise\n";
   print "  it is identical with the '@$POSSIBLE_PDFOUT[0]' option.\n";
   print "- '@$POSSIBLE_PDFOUT[2]' means you want to specify your own directory where the\n";
   print "  generated document should be written.\n";
   $PDFOUT=&choose_value("Which output directory?",$PDFOUT,$POSSIBLE_PDFOUT);

   if ( $PDFOUT eq @$POSSIBLE_PDFOUT[2] ) {
      print "\n----------------\n";
      print "You have choosen to specifiy a custom output directory.\n";
      $PDFCUSTOMDIR=&input_dir("What custom directory should be used?",$PDFCUSTOMDIR,$YES);
   }

   print "\n----------------\n";
   print "The sed executable to use can be specified.\n";
   print "Type 'sed' in order to use the sed in your path.\n\n";
   $SEDEXE=&input_text("What sed executable should be used?",$SEDEXE);

   print "\n----------------\n";
   print "The bibtex usage can be specified.\n";
   print "Possible values are: '@$POSSIBLE_BIBTEX[0]' (always run bibtex), '@$POSSIBLE_BIBTEX[1]' (never run\n";
   print "bibtex) and '@$POSSIBLE_BIBTEX[3]' (scan tex file for a bibtex entry and run it\n";
   print "if required).\n";
   $BIBTEX=&choose_value("How should bibtex be used?",$BIBTEX,$POSSIBLE_BIBTEX);

   print "\n----------------\n";
   print "The maximal number of runs for pdflatex can be specified.\n";
   $MAXRUNNO=&input_number("What should be the maximum number of runs for pdflatex?",$MAXRUNNO 1 9);

   print "\n----------------\n";
   print "The minimal number of runs for pdflatex can be specified.\n";
   print "Possible values are: 1 ... $MAXRUNNO.\n";
   $MINRUNNO=&input_number("What should be the minimum number of runs for pdflatex?",$MINRUNNO,1,$MAXRUNNO);

   print "\n----------------\n";
   print "The log directory is used to store information about the generation\n";
   print "process for later review, e.g. for debugging.\n";
   $LOGDIR=&input_dir("What log directory should be used?",$LOGDIR,$YES);

   print "\n----------------\n";
   print "$MYNAME can clean the log files before execution.\n";
   print "You might experience problems if you run $MYNAME on several documents\n";
   print "the same time. If you want to be on the safe side, answer '$NO'.\n";
   $CLEANLOGS=&question_ynu("Should the log files be cleaned before execution?",$CLEANLOGS);

   print "\n----------------\n";
   print "$MYNAME can check for the required executables.\n";
   $COMMANDCHECK=&question_ynu("Should $MYNAME check for the required executables?",$COMMANDCHECK);

   print "\n----------------\n";
   print "$MYNAME can use thumbpdf to include thumbnails of the document pages.\n";
   print "This requires Ghostscript 5.50 or higher.\n";
   $THUMBNAILS=&question_ynu("Should PNG thumbnails be created?",$THUMBNAILS);

   print "\n----------------\n";
   print "$MYNAME can force the call of makeindex if pdftex fails to do this.\n";
   $MAKEINDEX=&question_ynu("Should the call of makeindex be forced?",$MAKEINDEX);

   print "\n----------------\n";
   print "Additional options for pdflatex can be specified.\n";
   print "Normally, you can leave this blank.\n\n";
   $PDFTEXOPTS=&input_text("What additional options for pdflatex should be used? :", $PDFTEXOPTS);
   print "\n";
}

### check if the most important executables are installed on the system
# parameters: none

sub check_commands {
   ### check for which command
   &checkCommand("which","You can switch off all command checks by setting $COMMANDCHECK=$NO in the parameter section of $MYNAME.");

   ### sed executable
   # GNU sed version 3.02 or higher is recommended
   # Download: ftp://ftp.gnu.org/pub/gnu/sed
   if ( $SEDEXE eq "sed" ) {
      &checkCommand("sed","You should get GNU sed 3.02 or later: ftp://ftp.gnu.org/pub/gnu/sed");
   }

   ### pdftex executables
   # Homepage: http://tug.org/applications/pdftex
   &checkCommand("pdflatex","See pdftex homepage for details: http://tug.org/applications/pdftex");
   &checkCommand("epstopdf","See pdftex homepage for details: http://tug.org/applications/pdftex");

   if ( $THUMBNAILS eq $YES ) {
      &checkCommand("thumbpdf","You can switch off thumbpdf support by setting $THUMBNAILS=$NO in the parameter section of $MYNAME.");
   }

   ### bibtex executable
   if ( $BIBTEX ne $NO ) {
      &checkCommand("bibtex","You can switch off BibTeX support by setting $BIBTEX=$NO in the parameter section of $MYNAME.");
   }
}

#### generate the tmp file name from the original tex filename
#### and make sure that they are not the same
# parameter 1: orignal filename (with or without a path, but with .tex)

sub get_tmp_filename {
   my $original_name = $_[0];
   my $tmp_name = $original_name;

   $tmp_name =~ s/(\.tex)$/$TMPBASESUFFIX$1/;
      
   if ($original_name eq $tmp_name) {
      &abort("Original and temporary filenames are identical ($original_name).");
   }
   return $tmp_name;
}

### generate LaTeX file from LyX document with LyX itself
# parameter ($1): Lyx document
# parameter ($2): Latex document

sub generate_tex_file {
   my $lyx_doc = $_[0];
   my $tex_doc = $_[1];
   my $lyx_dir = "$ENV{'HOME'}/.lyx/";

   ### Check if LyX file can be accessed
   &check_file($lyx_doc,"Cannot read the specified LyX document!");

   ### Check if LaTeX file exists and is newer than the LyX file
   if ( -f $tex_doc and $tex_doc -nt $lyx_doc ) {
      print "\n";
      print "$MYNAME: LaTeX file is newer than LyX document '$lyx_doc'.\n";
      print "Using existing TeX file: $tex_doc\n";
      print "Remove it to force its new generation.\n";
   } else {
      ### export LaTeX file with LyX (needs a display!)
      &checkCommand("lyx","Cannot generate LaTeX document without LyX!");
      print "\n";
      print "$MYNAME: Exporting LaTeX file\n";
      
      foreach my $file ($lyx_dir."lyxpipe.out",$lyx_dir."lyxpipe.in",$tex_doc) {
         if ( -f $file ) { rename($file, $file.'~'); }
      }

      system "lyx --export latex $lyx_doc";

      ### check if LaTeX file now really exists
      &check_file($tex_doc,"The LaTeX document was not generated by LyX!");
   }
}

#### search TeX document for a certain text tag (e.g. author, title)
# parameter 1: file to parse
# parameter 2: full TeX tag name
# parameter 3: default text when tag is empty or could not be found
# return value: contents of the tag as a string

sub extract_tag_text {
   my $source=$_[0];
   my $tag_name=$_[1];
   my $default_text= defined($_[2]) ? $_[2] : "";
   my $result = undef;;
   my $error_message="Could not read TeX document to extract $tag_name";

   &check_file($source, $error_message.'.');
   open(SOURCE_FILE, "<$source") or
      &abort($error_message."($source).");

   while(<SOURCE_FILE>) {
      s/([^\])%.*$/$1/;
      if( /\\$tag_name(\[[^{]*\])?{([^{}]*)}/ ) {
         $result=$2; 
	 last;
      }
   }
   
   close SOURCE_FILE;
   
   if ( ! defined($result)) {
      print "\n$MYNAME: WARNING: Could not identify document's $tag_name correctly.\n";
      print "Maybe you have used a LaTeX tag inside the $tag_name which confuses me.\n";
      print "You can either set a $tag_name on the command line or\n";
      print "change the $tag_name of the LaTeX file in order to avoid the problem.\n";
      if ( $default_text ne "" ) {
         print "Using default $tag_name: $default_text\n";
	 $result=$default_text;
      } else {
         print "$tag_name field will be empty.\n";
      }
   } else {
      print "Document's $tag_name: $result\n";
   }
}

### generate hyperref parameters from given settings
# return_value: result

sub generate_parameters {
   my @params = ('pdftex');
   if ( $PAPERSIZE ne $NIL ) { push(@params, $PAPERSIZE); }
   if ( $LINKTOCPAGE eq $YES ) { push(@params, "linktocpage"); }
   if ( $TITLE ne $NIL ) { push(@params, "pdftitle={$TITLE}"); }
   if ( $AUTHOR ne $NIL ) { push(@params, "pdfauthor={$AUTHOR}"); }
   if ( $COLORLINKS eq $YES ) {
      push(@params, "colorlinks=true");
      if ( $LINKCOLOR ne $NIL ) { push(@params, "linkcolor={$LINKCOLOR}"); }
      if ( $PAGECOLOR ne $NIL ) { push(@params, "pagecolor={$PAGECOLOR}"); }
      if ( $URLCOLOR ne $NIL ) { push(@params, "urlcolor={$URLCOLOR}"); }
      if ( $CITECOLOR ne $NIL ) { push(@params, "citecolor={$CITECOLOR}"); }
   } else {
      push(@params, "colorlinks=false");
   }
   if ( $ADDITIONAL_PARAMETERS ne "" ) { push(@params, "$ADDITIONAL_PARAMETERS"); }
   return @params;
}

##### read and analyse configuration and options and adjust basic variables
##### accordingly
#### The following sources are considered (last value overrides previous)
# general configuration (global variables in the script)
# private configuration (in user's RC file)
# command line options

sub adjust_configuration {
   my $config_request=$NO;
   my $print_request=$NO;

   ### Check number of arguments
   if ( @ARGV == 0 ) {
      print "\n$MYNAME: I need at least one argument!\n";
      @usage;
      exit 1;
   }
   
   ##### command line options and private configuration files handling
   
   ### scan parameters (1st level)
   getopts('hvorb:c:p:i:t:a:l:n:d:',%cmd_options);
   while getopts('hvorb:c:p:i:t:a:l:n:d:',%cmd_options);
   {
      case "$OPTION" in;
         h) &help; exit 0 ;;;
         v) &print_version; exit 0 ;;;
         o) $print_request=$YES ;;;
         r) $config_request=$YES;;;
         *) &usage; exit 1 ;;;
      esac;
   }
   
   ### set parameters from rc file
   if ( -f $RC_FILENAME ) {
     &read_configuration;
     #### compatibilty with old RC files where SEDEXE could be ""
     if ( $SEDEXE eq "" ) { $SEDEXE=sed; }
   } else {
     if ( $print_request ne $YES and $config_request ne $YES ) {
        &abort "Script is not configured. Please run $MYNAME -r.";
     }
   }
   
   ### configure parameters
   if ( $config_request eq $YES ) {
     &configure;
     &write_configuration;
     &print_configuration;
     exit 0;
   }
   
   ### scan parameters (2nd level)
   $OPTIND=1;
   while getopts b:p:i:t:a:l:c:n:d: OPTION;
   {
     case "$OPTION" in;
       i) &setYNValue MAKEINDEX $OPTARG i ;;;
       t) $TITLE=$OPTARG ;;;
       a) $AUTHOR=$OPTARG ;;;
       b) &setValue BIBTEX $OPTARG b $POSSIBLE_BIBTEX ;;;
       p) &setValue PAPERSIZE $OPTARG p $POSSIBLE_PAPER ;;;
       c) &setYNValue COMMANDCHECK $OPTARG r ;;;
       n) &setYNValue THUMBNAILS $OPTARG n ;;;
       l) &setYNValue CLEANLOGS $OPTARG l ;;;
       d) if &check_dir($OPTARG);
   	     $PDFCUSTOMDIR=$OPTARG;
   	     $PDFOUT=@$POSSIBLE_PDFOUT[2];
   	  } else {
   	     &abort("Please, choose a VALID path.");
   	  fi ;;;
     esac;
   }
   
   ### print configuration parameters
   
   if ( $print_request eq $YES ) {
      &print_configuration;
      exit 0;
   }
   
   #### remove all command line options, leave the document argument as $1
   shift $(($OPTIND - 1));
}

#### do some test in order to secure as good as possible that we will
#### succeed before to much work was done and maybe some data as damaged

sub do_basic_test {
   ### make sure that TMPBASESUFFIX is not empty
   if ( $TMPBASESUFFIX eq "" ) {
      print "\n$MYNAME: CAUTION: Parameter TMPBASESUFFIX is not set.\n";
      &abort "Using these settings would destroy the original files!";
   }
   
   ##### check for required commands
   if ( $SEDEXE ne "`basename $SEDEXE`" and ! -x $SEDEXE ) {
      print "\n";
      print "$MYNAME: Specified sed executable not found (${SEDEXE})\n";
      print "Using sed executable in your path.\n";
      print "Maybe it does not work. GNU sed v3.02 or higher is recommended.\n";
      $SEDEXE='sed';
   }
   
   if ( $COMMANDCHECK ne $NO ) {
      &check_commands;
   }
}

#### prepare the script to write some information to specified log files

sub prepare_logfiles {
   ##### Preparing the LOGDIR
   if ! mkdir -p ${LOGDIR}
      print "\n";
      print "$MYNAME: Could not create log directory ($LOGDIR).\n";
      print "Aborting ...\n";
      exit 1;
   }
   
   if ( $LOGFILES and "`ls ${LOGDIR}`" and $CLEANLOGS eq $YES ) {
      print "\n";
      print "Removing old log files ($LOGDIR).\n";
      system "rm ${LOGDIR}pdflatex-*.log ${LOGDIR}bibtex-*.log ${LOGDIR}thumbpdf-*.log";
   } else {
      print "\n";
      print "All log files will be stored in ($LOGDIR).\n";
   }
   
   # setting the log files for the output of pdflatex, bibtex and thumbpdf
   $PDFLOGBASE=${LOGDIR}pdflatex-$$-;
   $BIBTEXLOG=${LOGDIR}bibtex-$$.log;
   $THUMBPDFLOG=${LOGDIR}thumbpdf-$$.log;
}

##### analyse document argument
#### process the one and only argument (besides the options) which specifies
#### which LaTeX document the user wants to translate to PDF
#### a lyx file will be translated to LaTeX first

sub process_doc_argument {
   
   ##### Getting document name and path
   $DOCUMENT="$_[0]";
   $DOCNAME=`basename $DOCUMENT`;
   $DOCPATH=`echo "$DOCUMENT" | ${SEDEXE} -e "s/^\(.*\)$DOCNAME/\1/"`;
   
   ###### change working directory to document directory
   if ( $DOCPATH ne "" ) {
      cd $DOCPATH;
   }
   
   ###### make DOCPATH an absolute path
   $DOCPATH = `pwd`.'/';
   
   ###### Cut off suffix and do lyx or tex specific stuff
   $DOCBASE=`basename $DOCNAME .lyx`;
   if ( $DOCBASE ne $DOCNAME ) {
      ### DOCNAME has an extention .lyx => Lyx document
      # generate Latex document if required
      &generate_tex_file($DOCBASE.'.lyx', $DOCBASE.'.tex');
   } else {
      ### given file is a LaTeX file
      # cut off .tex extension if there is one
      $DOCBASE=`basename $DOCNAME .tex`;
   
      ###### check access to given LaTeX document
      &check_file("$DOCBASE.tex", "Cannot read the specified LaTeX document!");
   }
   
   $PASSEDTEXDOC=${DOCPATH}${DOCBASE}.tex;
   $TMPBASE=${DOCBASE}${TMPBASESUFFIX}
}

#### we would like to get some more information from the actual
#### main LaTeX document before we really start
#### so this function parses the document and tries to get the info

sub parse_main_doc {
   ##### Get title and author from main LaTeX document
   if ( $TITLE eq "" ) {
      $TITLE=&extract_tag_text($PASSEDTEXDOC, 'title', $DEFAULT_TITLE);
   } else {
      print "Your document's title: $TITLE\n";
   }
   
   if ( $AUTHOR eq "" ) {
      $AUTHOR=&extract_tag_text($PASSEDTEXDOC, 'author', $DEFAULT_AUTHOR);
   } else {
      print "Your document's author: $AUTHOR\n";
   }
   
   print "\n";
   
   # translate hyperref settings to the actual package parameters 
   @HYPERREF_PARAMS = &generate_parameters;
   
   ###### change working directory to INPUTPATH if set
   # When the files' path (images, included documents, etc.) in your document is
   # relative to another directory than the PASSED document's directory.
   # This is useful when the calling application (e.g. LyX) generates a temporary
   # TeX file and calls the tex2pdf with it instead of the original file.
   $INPUTPATH=`$SEDEXE -n "s|^[\]def[\]input@path{\+\([^{}]*\)}\+|\1|1p" $PASSEDTEXDOC`;
   
   ## check if INPUTPATH is ok
   if ( $INPUTPATH ne "" ) {
      print "$MYNAME: Found an input path in the latex document: $INPUTPATH\n";
      if ( -d $INPUTPATH and -r $INPUTPATH ) {
         print "Change working directory to input path.\n";
         cd $INPUTPATH;
      } else {
          &abort "The retrieved input@path seems not to be valid.";
      }
   } else {
      print "$MYNAME: No input path in the latex document found.\n";
      print "Resources are expected to be relative to document's location: $DOCPATH\n";
   }
}

#### search for filenames in given TeX Tag in entire document
### skip all comments and duplicates while parsing
# parameter ($1): file to parse
# parameter ($2): full TeX tag name
# parameter ($3): regular expression for the filname suffix (including '.')
# $FOUND_FILES: result

sub extract_files {
   my $source=$_[0];
   my $tag_name=$_[1];
   my $suffix=$_[2];
   my $matched_file;
   $FOUND_FILES=();

   &check_file($source, "Could not access TeX document to extract filenames.");
   open(SOURCE_FILE, "<$source") or
      &abort("Could not open TeX document to extract filenames ($source)");

   while(<SOURCE_FILE>) {
      chomp;
      s/([^\])%.*$/$1/;
      while( /\\$tag_name(\[[^{]*\])?{(([^}]*\/)?[^}/.]+($suffix))}/ ) {
         $matched_file = $2; 
         if( &array_index(@FOUND_FILES, $matched_file) < 0 ) {
	    push(@FOUND_FILES, $matched_file);
	 }
      }
   }
   
   close SOURCE_FILE;
}

### Build a list of all files which are included from the root file.
# This function recurses, and is maybe smart enough to detect cycles.
# One input parameter for this ($1): a tex file.
# Be sure to set FILES to the empty string prior to calling this.

sub get_file_list {
   local $source = $_[0];
   local @imports = ();

   # This is the cycle avoidance logic.
   if ( @array_index(@REF_DOCS, $source) < 0 ) {
      # Make sure the file can be accessed
      &check_file($source, "Included TeX file seems not to be available. Path problem?");

      # Save the argument in the list of files.
      push(@REF_DOCS, $source);

      # Get the list of files included by the argument.
      &extract_files($source, 'include|input', '(\.tex)?');
      @imports=@FOUND_FILES;

      # Recurse.
      foreach my $file (@imports) {
         if( ! $file =~ /\.tex$/ ) { $file .= '.tex'; }
         &get_file_list($file);
      }
   }
}

### Convert given tex file to the temp tex file we need for pdftex
### major task is to change the reference in the tex files to the
### corresponding tmp files
# parameter 1: tex source file
# parameter 2: tex tmp file
# parameter 3: adjust the LaTeX preamble (default: $NO)

sub convert_tex2tmp {
   my $source = $_[0];
   my $target = $_[1];
   my $adjust_preamble = ($_[2] == $YES) ? $YES : $NO;
   my $read_err_msg = "Could not read original TeX document to generate temporary document";
   
   ### open source and target file
   &check_file($source, $read_err_msg . '.');
   open(SOURCE_FILE, "<$source") or
      &abort($read_err_msg . " ($source).");

   open(TARGET_FILE, ">$target") or
      &abort("Could not open file to write temporary TeX document ($target).");
   
   ### set target file as stdout
   select TARGET_FILE;
   
   if ( $adjust_preamble eq $YES ) {
      ### read, parse, modify and write the LaTeX preamble
      while(<SOURCE_FILE>) {
   
         # protect pdflatex execution mode
         s/^(\\batchmode)$/% $1/
   
         # print the read line
         print $_;
   
         # append our extra TeX commands after the matching line
         if ( /$INSERT_REGEXP/ ) {
            print '\usepackage{pslatex}' . "\n";
            
   	 if ( $THUMBNAILS eq $YES ) {
               print '\usepackage{thumbpdf}' . "\n";
   	 } else {
   	    print "% no thumbpdf support\n";
   	 }
   	 
            print '\makeatletter' . "\n";
            print '\usepackage['. join(',', @HYPERREF_PARAMS) . ']{hyperref}' . "\n";
            print '\makeatother' . "\n";
         }
   
         # if end of the preamble is reached stop loop
         if ( /^\\begin\{document\}$/ ) { last; }
      }
   }
   
   ### read, parse, modify and write the TeX body
   while(<SOURCE_FILE>) {
      s/(\\includegraphics)(\[[^]]*\])?(\{[^}]+)\.(e?ps|pstex)\}/$1$2$3}/g
      s/(\\input\{[^}]+\.)pstex_t\}/$1pdf_t}/g
      s/(\\(input|include)\{[^}]+)(\.tex)?\}/$1$TMPBASESUFFIX$3}/g

      # print the read and manipulted line
      print $_;
   }

   ### set STDOUT as stdout again
   select STDOUT;

   ### close files
   close SOURCE_FILE;
   close TARGET_FILE;
}

### Convert all given EPS images to PDF
# parameters ($@): list of EPS images with relative path to working directoy

sub convert_eps2pdf {
   my @image_list=@_;

   foreach my $image (@image_list) {
      my $image_path;
      my $image_base;
      my $image_name;
      my $suffix;
      my $image_target;

      ($image_base,$image_path,$suffix) = fileparse($image, ('\.eps', '\.ps', '\pstex'));
      $image_name = $image_base . $suffix;
      $image_target = $image_path . $image_base . '.pdf';
      
      #### check if image file really exists
      &check_file($image, "Could not convert referenced image.");

      if ( ! -f $image_target or -M $image_target > -M $image ) {
         print "Converting image $image_name ...\n";
         system("epstopdf", '-outfile='.$image_target, $image)
	    or &abort "epstopdf failed on $image_name: $!";
         push(@TMPFILES, $image_target);
      } else {
         print "$image_base.pdf newer than $image_name, conversion skipped...\n";
      }
   }
}

### Convert all given PSTEX_T files to PDF_T
# parameters ($@): list of PSTEX_T files with relative path to working directoy

sub convert_pstex2pdf {
   my @pstex_file_list = @_;

   foreach my $pstex_file (@pstex_file_list) {
      my $pstex_path;
      my $pstex_base;
      my $pstex_name;
      my $suffix;
      my $pstex_target;
      my @eps_images;

      ($pstex_base,$pstex_path,$suffix) = fileparse($pstex_file, ('\.pstex_t'));
      $pstex_name = $pstex_base . $suffix;
      $pstex_target = $pstex_path . $pstex_base . '.pdf_t';
      
      #### check if image file really exists
      &check_file($pstex_file, "Could not convert referenced file.");

      # descend into file
      print "Converting file $pstex_name ...\n";

      # find included EPS image(s)
      &extract_files($pstex_file, 'includegraphics', '\.pstex');
      @eps_images=@FOUND_FILES;

      # create .pdf_t file
      convert_tex2tmp($pstex_file, $pstex_target, $NO); 

      # convert image(s) to pdf
      &convert_eps2pdf(@eps_images);

      push(@TMPFILES, $pstex_target);
   }
}

### Converted included images to pdf
# parameter ($1): tex source file

sub convert_images {
   my $tex_source="$_[0]";
   my @pstex_file_list;
   my @eps_image_list;

   print "\nConverting images referenced in $tex_source.\n";

   ##### Get EPS images from the source file
   print "\nScanning for EPS images (.eps/.ps):\n";
   &extract_files($tex_source, 'includegraphics', '\.e\?ps');
   @eps_image_list=@FOUND_FILES;
   if ( @eps_image_list > 0 ) {
      print "@eps_image_list\n";
   } else {
      print "None.\n";
   }

   ##### Get PSTEX_T files from the source file
   print "\nScanning for PSTEX_T files (.pstex_t):\n";
   &extract_files($tex_source, 'input', '\.pstex_t');
   @pstex_file_list = @FOUND_FILES;
   if ( @pstex_file_list > 0 ) {
      print "@pstex_file_list\n";
   } else {
      print "None.\n";
   }

   ### Convert all EPS images to PDF
   if ( @eps_image_list > 0) {
      print "\n$MYNAME: Converting EPS images to pdf\n";
      &convert_eps2pdf(@eps_image_list);
   }

   ### Convert all PSTEX_T files to PDF_T
   if ( @pstex_file_list > 0 ) { 
      print "\n$MYNAME: Converting pstex_t docs to pdf_t docs\n";
      &convert_pstex2pdf(@pstex_file_list);
   }

   print "\nFinished converting for ${tex_source}.\n";
}

#### Prepare the main document and all referenced ones for the generation
#### of the PDF document (including referenced images)
# parameter 1: top level tex document

sub prepare_documents {
   my $main_tex_doc=$_[0];
   my $main_tmp_doc = &get_tmp_filename($main_tex_doc);
   @REF_DOCS=();

   ##### Get the list of imported files from the tex file
   &get_file_list($main_tex_doc);
   
   ## remove main file from list (first element; needs special handling)
   shift @REF_DOCS;
   
   ## tell user about the identified refereneced docs
   if ( @REF_DOCS > 0 ) {
      print "\nFound the following referenced TeX files:\n";
      foreach my $file (@REF_DOCS) {
         print ">>>>> $file\n";
      }
   } else {
      print "\nFound no included TeX files.\n";
   }
   
   ##### Generate adjusted temp tex files and convert all their images
   ## main doc
   print "\n$MYNAME: Generating main temporary LaTeX document: $main_tmp_doc\n";
   &convert_tex2tmp($main_tex_doc, $main_tmp_doc, $YES);
   &convert_images($main_tex_doc);
   
   ## referenced docs
   foreach my $file (@REF_DOCS) {
      my $tmp_file = &get_tmp_filename($file);
   
      ### Insert pdf conversation tags in tex file and write it to tmp_file
      print "\n$MYNAME: Generating temporary LaTeX document: $tmp_file\n";
      &convert_tex2tmp($file, $tmp_file);
      &convert_images($file);
   }
}

### run pdflatex
# parameter $1: LaTeX file without extension
# parameter $2: log-file where the full out put is stored
# return value: 0 - no errors (no rerun); 1 - errors (rerun required)

sub run_pdflatex {
   local $TEXFILE=$_[0];
   local $errors=0;
   local $PDFLOGFILE=$_[1];
   local $exit_status=0;
   print "Pdflatex is running. Please wait.\n\n";
   pdflatex --interaction nonstopmode ${PDFTEXOPTS} ${TEXFILE} > $PDFLOGFILE;
   $exit_status=$?;
   print "Pdflatex finished. Errors:\n";
   $errors=`grep "! Emergency stop\|Error:\|LaTeX Warning:" $PDFLOGFILE | wc -l`;
   if ( $errors != 0 or $exit_status -ne 0 ) {
      if ( "`grep '! Emergency stop' $PDFLOGFILE`" ) {
         cat $PDFLOGFILE;
	 print "\n";
	 &abort "Fatal error occured. I am lost.";
      }
      if ( $errors != 0 ) {
         grep "Error:\|LaTeX Warning:" $PDFLOGFILE;
      } else {
         tail $PDFLOGFILE;
      }
      print "\n$MYNAME: See $PDFLOGFILE for details.\n";
      return 1;
   } else {
      print "None detected (log file: $PDFLOGFILE).\n";
      return 0;
   }
}

#### run bibtex if BIBTEX=$YES or a bibliography tag is found
# included tex files are not parsed for a bibliography
# parmeter $1: filename of the aux file without .aux suffix

sub handle_bibtex  {
   $AUXFILE=$_[0];
   print "\n";
   if ( $BIBTEX eq $YES ) {
      $BIBLIO=1;
      print "$MYNAME: BibTeX paramter set to '$YES'; running BibTeX.\n";
   } else {
      print "$MYNAME: Checking for BibTeX bibliography in document.\n";
      $BIBLIO=`grep "^[^%]*[\]bibliography{" ${AUXFILE}.tex | wc -l`;
      if ( $BIBLIO != 0 ) {
         print "Bibliography detected; running BibTeX.\n";
      } else {
         print "No bibliography detected.\n";
      }
   }
   if ( $BIBLIO != 0 ) {
      if ! bibtex ${AUXFILE} > ${BIBTEXLOG}
         $BIBTEXERR=1;
      } else {
         $BIBTEXERR=`grep "error message" ${BIBTEXLOG} | wc -l`;
      }
      if ( $BIBTEXERR != 0 ) {
         print "\n";
         print "****************** BibTeX errors reported *******************\n";
         cat ${BIBTEXLOG}
         print "*************************************************************\n";
         print "\n$MYNAME: You can switch off BibTeX support by setting $BIBTEX=$NO in the parameter section of $MYNAME.\n";
      } else {
         print "BibTeX finished without errors.\n";
      }
   }
}

#### run thumbpdf command to make thumbnails
# more informations: /usr/share/texmf/doc/pdftex/thumbpdf/readme.txt
# parameter $1: LaTeX file without extension

sub run_thumbpdf  {
   local $TEXFILE=$_[0];
   local $exit_status=0;
   print "\n$MYNAME: Creating thumbnails with 'thumbpdf'\n\n";
   thumbpdf ${TEXFILE}
   $exit_status=$?;
   if ( $exit_status != 0 ) {
      print "\n$MYNAME: thumbpdf exit with status $exit_status.\n";
      print "I will continue, but maybe there will not be thumbs in the PDF doc.\n";
   }

   if ( -f thumbpdf.log ) {
      mv thumbpdf.log $THUMBPDFLOG;
      print "\n$MYNAME: See $THUMBPDFLOG for details.\n";
   }

   print "\nCleaning up (thumbpdf) ...\n\n";
   system "rm -f thumb???.png";
   system "rm -f thumbpdf.pdf";
   if ( -f "thumbdta.tex" ) { push(@TMPFILES, "thumbdta.tex"); }
}

##### Generate the final PDF document
# parameter 1: filename of the LaTeX document (with extension)

sub generate_pdf_doc {
   my $tex_doc = $_[0];
   my $index_file;
   my $runno=1;
   my $rerun=$TRUE;

   ### cut of .tex extension - pdflatex does not like it
   $tex_doc =~ s/\.tex$//;
   $index_file = $tex_doc.'.idx';
   
   ### run pdflatex until no more errors are reported (max MAXRUNNO)
   while ( $rerun == $TRUE and $runno <= $MAXRUNNO )
   {
      print "\n************ Pdflatex run no. $runno *************\n";
      if ( &run_pdflatex($tex_doc, $PDFLOGBASE.$runno.'.log') == $TRUE 
         and ( $MINRUNNO <= $runno )) {
         # no errors detected and MINRUNNO is processed
         $rerun=$FALSE;
      } else {
         # errors appeared or MINRUNNO has not been reached
         $rerun=1;
      }
   
      ### Execute BibTeX after first run if set (and required)
      if ( $runno == 1 and $BIBTEX ne $NO ) {
         &handle_bibtex($tex_doc);
      }
   
      $runno += 1;
   }
   
   $rerun = $FALSE;
   
   ### if the THUMBNAILS option is switched on then make thumbnails
   if ( $THUMBNAILS eq $YES ) {
      &run_thumbpdf($tex_doc);
      $rerun=$TRUE;
   }
   
   ### generate index if required
   if ( -f $index_file and $MAKEINDEX ne $NO ) {
      print "\n$MYNAME: Document seems to have an index. Generating ...\n\n";
      &makeindex($index_file);
      $rerun=$TRUE;
   }
   
   ### One final pdflatex run if requested
   if ( $rerun == $TRUE ) {
      print "\n************ One final pdflatex run no. $runno *************\n";
      &run_pdflatex($tex_doc, $PDFLOGBASE.$runno.'.log');
   }
}
   
################## Lift off !!!! (main part) ##################
$TMPBASE=;
@TMPFILES=();
$TITLE=;
$AUTHOR=;

print "\n$MYNAME: Script starts (Release $MYRELEASE)\n";

##### read and analyse configuration and options and adjust basic variables
##### accordingly
##### write RC file on config request

print "\n$MYNAME: Processing given parameters and arguments.\n";
&adjust_configuration(@_);

#### use the finished configuration to get all further settings before we
#### actually start doing something

print "\n$MYNAME: Doing some testing.\n";
&do_basic_test;

#### prepare the script to write some information to specified log files

print "\n$MYNAME: Preparing log files.\n";
&prepare_logfiles;

#### process the one and only argument (besides the options) which specifies
#### which LaTeX document the user wants to translate to PDF
#### a lyx file will be translated to LaTeX first

print "\n$MYNAME: Analysing your document argument.\n";
&process_doc_argument;

#### we would like to get some more information from the actual
#### main LaTeX document before we really start
#### parse the document and try to get the info

print "\n$MYNAME: Parsing main LaTeX document.\n";
&parse_main_doc;
   
##### set the directory where the final pdf will be stored
$PDFOUTDIR=;
if ($PDFOUT eq @$POSSIBLE_PDFOUT[2]) {
   $PDFOUTDIR=$PDFCUSTOMDIR;
} elsif ($PDFOUT eq @$POSSIBLE_PDFOUT[1]) {
   $PDFOUTDIR=$INPUTPATH;
} else {
   $PDFOUTDIR=$DOCPATH;
}

## as much as possible is prepared in advance at this point
## so hopefully we will succeed in generating the PDF document

##### real work starts NOW

##### Generate adjusted temp tex files and convert all their images

print "\n$MYNAME: Preparing all documents and images.\n";
&prepare_documents($PASSEDTEXDOC);

##### Generate the final PDF document

print "\n$MYNAME: Processing the actual generation of the PDF document.\n";
&generate_pdf_doc($PASSEDTEXDOC);

##### Clean up
if ( ! -f $TMPBASE.'.pdf' ) {
   print "\n";
   &abort "The PDF file $TMPBASE.pdf was not generated.";
}

rename($TMPBASE.'.pdf', $PDFOUTDIR.$DOCBASE.'.pdf');
print "\n";
&clean_up;
print "\nThe new pdf file is: ${PDFOUTDIR}${DOCBASE}.pdf\n\n";

